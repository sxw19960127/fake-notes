# 在`node`中使用模板引擎

`art-template`

可在浏览器中使用，还可在`node`中使用。

**下载步骤**：

- 在浏览器`url`部分输入`github.com`+`tab`，在`github`里面进行搜索 
- 搜`art-template`
- 进入官网，在文档里进行学习使用

[github地址](https://github.com/aui/art-template)

[官网](https://aui.github.io/art-template/)



### 使用起步

- 使用`npm`进行包下载：于目标文件下，在命令行中 `npm install art-template`。该命令在哪执行就会把包下载到那里，默认会下载到`node_modules`目录下。`mode_modules`是目标包的相互依赖包的集合，切勿修改。
- 解决`npm`报错情况：`npm WARN webpack-starter@1.0.0 No repository field.`。报错原因是，在目标文件夹中没有`package.json`配置项。解决方法：新建`package.json`并配置：

```js
{
    "repository": {
        "type": "git",
        "private": true
    }
}
```

![art_template](C:\Users\lenovo\Desktop\2019年11月19日始\notes\Node\img\art_template.png)

**在浏览器中使用`art-template`**

上述图片中的`template-web.js`便是使用于浏览器端的`js`文件。

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
</head>
<body>
   <!-- 引入用于浏览器端的模板引擎 -->
   <script src="./node_modules/art-template/lib/template-web.js"></script>

   <!-- 注意,这里的 type 只要不是 text/jsvascript 就行。防止浏览器将其当作 js 进行解析 -->
   <script type="text/template" id="tp1">
      我叫：{{ name }}
      我今年：{{ age }}
      我来自：{{ province }}
      我喜欢：{{ each hobbies }} {{ $value }} {{ /each }} 
   </script>
   <script>
      var ret = template('tp1', {
         name: 'sxw',
         age: 18,
         province: '浙江省',
         hobbies: [
            '写代码',
            '唱歌',
            '跑步'
         ]
      })
      console.log(ret);
      // 模板引擎不关心我们写的内容，只关心自己认识的模板标记语法，如： {{ ... }}
      // {{}} 语法被称之为 mustache 语法 
   </script>
</body>
</html>
```



**在`node`中使用`art-template`模板引擎**

起步：

- 模板引擎最早诞生于服务器领域，后来才发展到了前端 

- 安装 `npm install art-template`

- 在需要使用的文件模板中加载`art-template`

  使用`require`方法进行加载：`require('art-template')`

  参数中`art-template`就是我们下载包的名字

  即`install`的名字是什么，`require`后就跟什么

- 查文档，使用模板引擎的`API`

使用：

**版本1**：

```js
var template = require('art-template');
var ret = template.render('hello {{ name }}', {
	name: 'node'
})
console.log(ret);
```

**版本2**：

```js
var template = require('art-template');
var tplStr = `
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
</head>
<body>
   <p>我叫{{ name }}</p>
   <p>我今年{{age }}</p>
   <h1>我来自{{ province }}</h1>
   <p>我喜欢{{each hobbies}} {{$value}} {{/each}}</p>
</body>
</html>
`
var ret = template.render(tplStr, {
	name: 'sxw',
	age: 18,
	province: '兰溪市',
	hobbies: [
		'写代码',
		'跑步',
		'听歌'
	]
})
console.log(ret)
```

**版本3**：

将上述反引号包裹起来的`html`模板字符串放到外部文件中。

通过读取文件的形式，将模板文件读取出来。

```js
var template = require('art-template');
var fs = require('fs');

// index.html 就是版本2中反引号里的内容
fs.readFile('./index.html', function(err,data) {
	if(err) {
		return console.log('读取文件失败了')
	}
	// 默认读取到的 data 是二进制的数据
	// 而模板引擎的 render 方法接收的是字符串
	// 所以我们需要将 data 中的二进制数据转为字符串，再交给模板引擎去使用
    // 通过 toString() 方法即可
	var ret = template.render(data.toString(), {
        name: 'sxw',
        age: 18,
        province: '兰溪市',
        hobbies: [
            '写代码',
            '听歌'
        ]
	})
	console.log(ret);
})
```



**代码风格**：

无分号：

- （
- 【
- `

书籍推荐：《编写可维护的`JavaScript`》



### 客户端渲染和服务端渲染

**客户端渲染：**

![客户端渲染](C:\Users\lenovo\Desktop\2019年11月19日始\notes\Node\img\客户端渲染.png)



**服务端渲染（在服务端使用模板引擎）**：

![服务端渲染](C:\Users\lenovo\Desktop\2019年11月19日始\notes\Node\img\服务端渲染.png)

两者比较：

- 服务端渲染（eg：淘宝网中的商品信息数据）：有刷新，可被爬虫抓取，右键源码能够找到，利于`seo`优化
- 客户端渲染（eg：淘宝网中的用户评价列表）：异步，`ajax`渲染数据，爬虫抓取不到，无刷新，更快

