# `node`中的模块系统

用`node`编写应用程序主要就是使用：

- `ecmascript`语言
- 核心模块
- 第三方模块（必须使用`npm`进行下载）
- 自己写的模块（自己创建的文件）



**commonjs模块规范**：

- 模块作用域
- 使用`require`方法来加载模块
- 使用`export`接口对象来导出模块中的成员



**练习**：

`a.js`

```js
require ('./b')

console.log(foo) // 报错
```

`b.js`

```js
var foo = 'bar'
```

------------

`main.js`

```js
var fooExports = require('./foo')

console.log(fooExports) // function add(x,y){}
```

`foo.js`

```js
var foo = 'bar'

function add(x,y) {
	return x + y
}

// 外部只能得到我想要给你的成员,有利于解决变量命名冲突的问题
export.add = add

// exports是一个对象,可以通过多次为这个对象添加成员来实现向外一次性导出多个成员
exports.str = 'hello'

// 可以理解为在每个模块最后都 return 了 exports 这个对象出去
```

----------

`main.js`

```js
var fooExports = require('./foo')

console.log(fooExports)
```

`foo.js`

```js
var foo = 'bar'
function add(x,y) {
	return x + y
}

module.exoprts = add
// 如果一个模块需要直接导出某个成员,而非挂载的方式,使用 module.exports = xxx;
```



**加载require**：

语法：

```js
var 自定义变量名称 = require('模块');
```

作用：

- 执行被加载模块中的代码
- 得到被加载模块中的`exports`导出接口对象

**导出exports**：

- `node`是模块作用域，默认文件中所有的成员只在当前文件模块中有效
- 对于希望被其他模块访问的成员，将其都挂载到`exoprts`接口对象上就可以了

```js
exports.a = 123;
exoprts.b = function() {
	console.log('aaa')
}
```



导出单个成员：拿到的就是函数、字符串。

```js
module.exports = 'hello'
```

后者覆盖前者。

```js
module.exports = 'hello'

// 覆盖前者
module.exports = function(x,y) {
	return x + y;
}
```

导出多个成员：

```js
module.exports = {
	add: function() {
		return x + y
	},
	str: 'hello'
}
```



### 原理解析：`exports`和`module.exports`

```js
console.log(exports === module.exports) // true
```

```js
exports.foo = 'bar'
// 等价于
moudle.exports.foo = 'bar'
```

在`node`中，每个模块都有一个自己的`module`对象。该`module`对象中，有一个成员叫`exports`，也是一个对象，即：

```js
var module = {
	exports: {
		
	}
}
```

默认在代码的最后有一句：`return module.exports`。谁来`require`我，谁就得到`module.exports`这个对象。



**node为简化操作，内部帮我们实现了 exports = module.exports **

也就是说：==exports== 只是 ==module.exoprts== 的一个引用。当我们给`exports`重新赋值的时候，并没有什么用，因为最后文件返回的还是 ==module.exports== 对象。

```js
var obj = {}
var obj1 = obj

obj1.foo = 'bar'
obj.foo = 'hello'
obj1 = {}
obj1.foo = 'world'

console.log(obj.foo); //hello
```

**重新赋值之前，所有的属性都会同步到 module.exports 上去，赋值之后的以下步骤不会生效**

```js
exports.a = 123

exports = {} // 重新赋值
exoprts.foo = 'bar' // 不生效
```

**给 exports 和 module.exports 两个重新赋值后，都会断开两者之间的相互联系。要记住，我们最后导出的是 modele.exports。exports 对象和 module.exports 对象指向同一个内存地址，只是 node 官方为了简便计算来实现的操作，如果不能理解可忽略**

```js
module.exports = 'hello' // 重新赋值,断开引用,但最终返回的还是这个

exports.foo = 'world'; // 不生效
```

```js
// 重新赋值,断开链接
module.exports = {
	foo: 'bar'
}
// 重新建立链接
exports = module.exports

exports.foo = 'hello' // 生效{foo: 'hello'}
```

```js
exports.foo = 'bar'

module.exports.a = 123

exports = {
	a: 456
}

modules.exports.foo = 'haha'

exports.c = 456

exports = modules.exports

exports.a = 789
// 最后返回 {foo: 'haha', a: 789}
```

**以上需要注意的一点是：对象的属性赋值和对象自身等于的区别，如果前面对象赋值的很多，只要导出对象被重新赋值了，就gg**

```js
modules.exports.foo = 'haha'
modules.exports = function() { // 重新赋值，前面都没用了
...
}
```

**写在最后**：

真正在使用的时候：

​	导出多个成员：`exports.xxx=xxx`，也可以`module.exports = {...}`

​	导出单个成员：`module.exports`

官网说：如果真的分不清楚两者的区别，可以选择忘记`exports`而只使用`module.exports`。



### `require`加载规则

- 核心模块
- 第三方模块
- 用户自己写的

优先从缓存进行加载，再判断模块标识

- 核心模块
- 第三方模块
- 自己写的模块

栗子：有三个文件

`main.js`

```js
require('./a')
require('./b') 
// 不会重复去加载 b.js,因为在 a.js 中已经加载过 b.js 了,只会得到 b.js 里面的接口对象,实现提高性能的目的
```

`a.js`

```js
console.log('a 被执行了')

require('./b')
```

`b.js`

```js
console.log('b 被执行了')
```

以上代码只会打印出`a.js`被加载了`b.js`被加载了。



**文件加载规则**：

- 优先从缓存加载
- 核心模块
- 路径形式的文件模块
- 第三方模块

- `var template = require('art-template')`
- 先找到当前文件所处目录中的`node_modules`目录
- `node_mdules/art-template`
- `node_mdules/art-template/package.json`文件
- `node_mdules/art-template/package.json`文件中的`main`属性
- `main`属性中就记载了`art-template`的入口模块，其实加载的就是她

注意：如果`package.json`文件不存在或者`main`指定的入口模块也没有，则`node`会自动去找该目录下的`index.js`。

如果以上任何一个条件都不成立，则会进入上一级目录中的`node_modules`目录中查找。如果上一级还没有，则继续往上一级查找。。。直到当前磁盘根目录还找不到，最后报错。`can not find module xxx`。

