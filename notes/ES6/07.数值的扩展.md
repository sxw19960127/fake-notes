# 数值的扩展

[TOC]

## 1.二进制和八进制表示法

`ES6`提供了二进制和八进制数值的新写法，分别用前缀`0b`（或`0B`）和`0o`（或`0O`）表示。

```javascript
0b111110111 === 503 // true
0o767 === 503 // true
```

从`ES5`开始，在严格模式之中，八进制就不再允许使用前缀`0`表示，`ES6`进一步明确，要使用前缀`0o`表示。

```javascript
// 非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  'use strict';
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
```

如果要将`0b`和`0o`前缀的字符串数值转为十进制，要使用`Number`方法。

```javascript
Number('0b111')  // 7
Number('0o10')  // 8
```

## 2.`Number.isFinite(),Number.isNaN()`

`Number.isFinite()`用来检查一个数值是否为有限的，即不是`Infinity`。

注意：如果参数类型不是数值，一律返回`false`。

```javascript
Number.isFinite(15); // true
Number.isFinite(NaN); // false
Number.isFinite(Infinity); // false
Number.isFinite('foo'); // false
Number.isFinite('15'); // false
Number.isFinite(true); // false
```

`Number.isNaN()`用来检查一个值是否为`NaN`。

```javascript
Number.isNaN(NaN) // true
Number.isNaN(9/NaN) // true
Number.isNaN('true' / 0) // true
Number.isNaN('true' / 'true') // true
```

与传统全局方法`isFinite()`和`isNaN()`的区别：

- 传统方法先调用`Number()`将非数值的值转为数值，再进行判断
- 这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回`false`, `Number.isNaN()`只有对于`NaN`才返回`true`，非`NaN`一律返回`false`。

```javascript
isFinite(25) // true
isFinite("25") // true
Number.isFinite(25) // true
Number.isFinite("25") // false

isNaN(NaN) // true
isNaN("NaN") // true
Number.isNaN(NaN) // true
Number.isNaN("NaN") // false
Number.isNaN(1) // false
```

## 3.`Number.parseInt(), Number.parseFloat()`

将全局方法`parseInt()`和`parseFloat()`，移植到`Number`对象上，行为完全保持不变。

```javascript
// ES5的写法
parseInt('12.34') // 12
parseFloat('123.45#') // 123.45

// ES6的写法
Number.parseInt('12.34') // 12
Number.parseFloat('123.45#') // 123.45
```

目的：逐步减少全局性方法，使得语言逐步模块化。

```javascript
Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true
```

## 4.`Number.isInteger()`

判断一个数值是否为整数。

```javascript
Number.isInteger(25) // true
Number.isInteger(25.1) // false

Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger('15') // false
Number.isInteger(true) // false
```

`JavaScript`内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。

```javascript
Number.isInteger(25) // true
Number.isInteger(25.0) // true
```

注意：如果数值的精度超过限度，`Number.isInteger`可能会误判。

```javascript
Number.isInteger(3.0000000000000002) // true
```

还有，如果一个数值的绝对值小于`Number.MIN_VALUE`，即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，`Number.isInteger`也会误判。

```javascript
Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
```

上面代码中，`5E-325`由于值太小，会被自动转为0，因此返回`true`。

总结：如果对数据精度的要求较高，不建议使用`Number.isInteger()`判断一个数值是否为整数。

## 5.`Math`对象的扩展

### `Math.trunc()`

 去除一个数的小数部分，返回整数部分。

### `Math.sign()`

 判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 

 