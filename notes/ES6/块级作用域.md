没有块级作用域时存在的问题

```js
// if不会产生块级作用域
var func;
if(true) {
    var name = 'sxw'
    func = function() {
        // 我们本意是让打印出 if 中定义的变量 name
        console.log(name)
    }
}
// 由于 if 不会产生块级作用域,导致我们随便在哪里都能够改变变量 name 的数值
name = '111'
func()
```

```html
// for不会产生块级作用域
// 需求: 点击第几个 button 显示对应的数字
// 结果: 始终显示 3

<button></button>
<button></button>
<button></button>
<script>
	var btns = document.getElementsByTagName('button')
    for(var i = 0;i < btns.length;i ++) {
        btns[i].addEventListener('click', function() {
            console.log(i)
        })
    }
</script>
```

在没有`es6`的时候，我们是如果来解决上述问题的？

闭包，使用了函数具备作用域的特点来解决了问题。

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
</head>
<body>
   <button>1</button>
   <button>2</button>
   <button>3</button>
   <script>
      var btns = document.getElementsByTagName('button')
      for(var i = 0;i < btns.length;i ++) {
         // 因为函数具有作用域,一旦外部传递进来一个变量值之后,便会强制保存起来,不能被随意改变了
         (function(j) {
            console.log(j)
         })(i)
      }
   </script>
</body>
</html>
```

函数具有自己的作用域：

```js
// 定义全局变量
var name = 'sxw'
function test(name) {
    console.log(name)
}
// 改变全局变量
name = '111'
// 给函数传递实参不受外部变量影响
test('sxw111')
```

```js
var name = 'sxw'
function test(name) {
    console.log(name)
}
test(name)
// 这是改变全局变量不起作用
name = '111'
```

==注意==：`js`被设计的时候，只有函数具有作用域，像`if`、`for`这些是没有自己的作用域的。

在`es6`之前，因为`if`和`for`都没有块级作用域的概念，很多时候，我们都必须借助于`function`的作用域来解决外面变量的问题。现在`es6`中加入了`let`，可以完美的解决这些作用域的问题。

```js
// 上述问题,使用 let 进行解决
const btns = document.getElementsByTagName('button')
for(let i = 0;i < btns.length;i ++) {
    console.log(i)
}
```



`let`和`const`之间的区别：`const`主要是将某个变量修饰为常量，不可再次赋值修改。

```js
const name; // 报错,const声明和赋值变量是一起的
```

```js
const name = 'sxw'
name = '111' // 报错,一旦使用 const 声明的常量被赋值之后便不能修改了
```

```js
// 常量的涵义是指向的对象不能修改,但可以修改对象内部的属性,即内存地址是不能够被改变的,但是对象中的具体属性是可以被改变的
const obj = {
    name: 'sxw',
    age: 18
}
obj = {} // 改变了内存地址,报错

obj.name = 'iu' // 修改内存地址中的内部属性是支持的
obj.age = 3; 
console.log(obj)
```

总结：其实对象在内存中都有自己的地址，而我们所保存的对象，其实质是保存了对象的内存地址，通过内存地址去访问到对应的对象。当我们`const`的时候，当前的内存地址不能被修改了，但是内存地址中的属性是能够被修改的。

==建议==：开发中，优先使用`const`。



对象的增强写法：

```js
// 属性的增强写法
const name = 'sxw'
const age = 18

// es5的写法
var obj = {
    name: name,
    age: age
}

// es6的写法
const obj = {
    name,
    age
}
```

```js
// 函数的增强写法
const obj = {
    // es5 的写法
    fun: function() {}
    
    // es6的写法
    fun() {}
}
```



