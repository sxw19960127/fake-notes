```
方法/函数:
1)方法的构成
    简单的输入输出(浏览器提供)
    	window.alert(字面值/变量);
    	window.document.write(字面值/变量);
    	console.log(字面值/变量);
    var a = window.confirm(提示字符串); 
    alert(a);
    
    var input = window.prompt(提示字符串,默认值); //浏览器自带的弹出输入框,默认值可不写
2)定义方法
    var 方法名 = function(形参) {
        return 输出; 
    };
执行方法:
    a)方法名(实参);
    b)var a = 方法名(实参);
    c)call改变this指向;
    d)apply改变this指向;
    e)bind改变this指向;
```

```
//判断一个数是否是偶数,取模是否为0来判断
var isEven1 = function(n) { 
    if(n % 2 === 0) {
        return true;
    }else {
        return false;
    } 
};

var isEven2 = function(n) { 
    if(n % 2 === 0) {
        return true;
    }
    return false;
};

var isEven3 = function(n) { 
    return n % 2 === 0;
};
```

```
//判断某年是否是闰年        
var isLeapYear = function(y) {
    //情况1: 四年一闰,百年不闰;
    //情况2: 四百年再闰;
    if((y % 4 === 0 && y % 100 !== 0) || y % 400 === 0) {
        return true;
    }
    return false;
};
```

```
//判断3个数是否能够构成三角形
var isTriangle = function(a, b, c) {
    // 三角形成立的条件是:任意两边之和大于第三边或者任意两边之差小于第三边
    if(a + b > c && a + c > b && b + c > a) {
        return true;
    }
    return false;
};
```

```
//返回较大的那个数 
var max2 = function(a,b) {
    if(a>b) {
        return a;
    }
    return b;
};
//传入三个数,返回最大的那个数
//方法1:
var max3 = function(a,b,c) {
    if(a>b && a>c) {
        return a;
    }
    if(b>a && b>c) {
        return b;
    }
    return c;
};
//方法2:调用方法,实现方法的复用 
var max3 = function(a,b,c) {
    return max2(a, max2(b,c));
};
```

```
//传入1-7,输出对应星期的英文单词
var weekEnglish = function(n) {
    switch(n) {
        case 1:
            return "Monday";
        case 2:
            return "Tuesday";
        case 3:
            return "Wednesday";
        case 4:
            return "Thursday";
        case 5:
            return "Friday";
        case 6:
            return "Satursday";
        case 7:
            return "Sunday";
    }
    return "无法识别";
};
var input = prompt("请输入1-7","");
input = parseInt(input, 10);
if(isNaN (input)) {
    alert("输入错误");
}else {
    var work = weekEnglish(input);
    alert("星期" + input + "的单词是" + work);
}
```

```
//输入出生年返回所属生肖	   猴鸡狗猪鼠牛虎兔龙蛇马羊
var judgeAnimalYear = function(y) {
    switch(y % 12) {
        case 0:
            return "猴";
        case 1:
            return "鸡";
        case 2:
            return "狗";
        case 3:
            return "猪";
        case 4:
            return "鼠";
        case 5:
            return "牛";
        case 6:
            return "虎";
        case 7:
            return "兔";
        case 8:
            return "龙";
        case 9:
            return "蛇";
        case 10:
            return "马";
        case 11:
            return "羊";
    }
    return null;
} 
var run = function() {
    var input = prompt("请输入您的出生年，如1996", "");
    var year = parseInt(input);
    var animal = judgeAnimalYear(year);
    alert("您的生肖是：" + animal);
};
run();
```

```
// var f3 = function() {
//     for(var i = 1;i <= 10;i = i + 1) {
//         document.write(i + " ");
//     }
// };
// f3();

var f2 = function() {
    var i = 1;
    i = ++i+i++; //i=4
};
```

```
var a = 1 && 2; //a=2
var b = false && 1 || "abc"; //abc
b = false && 1 && "abc"; //false
b = false || 1 && "abc"; //abc
```

```
//传入数字,判断是否是2,3,4的倍数
var judge234 = function(n) {
    if(n%2 === 0&&n%3 === 0&&n%4 === 0) {
        return true;
    }
    return false;
};
var q1 = function() {
    var input = parseInt(prompt("请输入一个数,我帮你判断是否是2,3,4的倍数", ""), 10);
    var result = judge234(input);
    if(result) {
        document.write(input + "是2,3,4的倍数");
    }else {
        document.write(input + "不是2,3,4的倍数"); 
    }
};

//传入三个数,打印最小值
var min3 = function(a, b, c) { 
    if(a > b) {
        a = b;
    } 
    if(a > c) {
        return c;
    }
    return a;
};

//让用户输入a,然后输入b,然后选择+-*/四种运算符
var calcExpretions = function(a, b, op) {
    switch(op) {
        case "+":   
            return a+b;
        case "-":
            return a-b;
        case "*":
            return a*b;
        case "/":
	        if(b === 0) {
	            return "NaN";
	        }
	            return a/b;
    }
};
var q8 = function() {
    var a = parseInt(prompt("请输入a", ""), 10);
    var b = parseInt(prompt("请输入b", ""), 10);
    var op = prompt("请输入运算符(+-*/)", "");
    var result = calcExpretions(a, b, op);
    if(isNaN (result)) {
        alert("除数不能为0");
    }else {
        alert(a + "" + op + "" + b + " = " + result);
    }
};
q8();

9.	var x = 567;
    var a = (x - x % 100) / 100 % 10;
    var b = (x - x % 10) / 10 % 10;
    var c = (x - x % 1) / 1 % 10;
    alert("第一位是："+ a + "第二位是：" + b + "第三位是:" + c);

	var a = 1;
	var f = function(a) {
	    a = 2; //修改的是局部变量(方法参数)
	};
	alert(a); //1 
	f();

//输出100以内的奇数
var f3 = function() {
    var n = 1;
    while(n < 100) {
        document.write(n + " ");
        n = n + 2;
    }
};
f3();

//100以内能被3整除的数
var f4 = function() {
    var n = 100;
    while(n > 0) {
        if(n % 3 === 0) {
            document.write(n + " ");
        }
        n = n - 1;
    }
};
f4();

//输出1-9没有2
var f1 = function() {
    var n = 0;
    while(n < 10) {
        n = n + 1;
        if(n === 2) {
            continue; //不往下走了,返回判断
        }
        document.write(n + " ");
    }
};
f1();

//输出100以内的偶数
var f1 = function() {
    var n = 0;
    while(n <= 50) {
        document.write((n * 2) + " ");
        n = n + 1;
    }
};
f1();

//烧脑,会执行9次
var f7 = function() {
    var i = 1; j = 1;
    while(i < 10) {
        while(j < 10) {
            j = j + 1;
            docunemnt.write("x");
        }
        i = i + 1;
    }
};
//执行81次
var f7 = function() {
    var i = 1; var j;
    while(i < 10) {
        j = 1; //不要在循环体内创建变量
        while(j < 10) {
            j = j + 1;
            docunemnt.write("x");
        }
        i = i + 1;
    }
};

//九九乘法表
var f1 = function() {
    var i = 1;var j = 1;
    while(i < 10) {
        j = 1;
        while(j <= i) {
            document.write(i + "x" + j + "=" + (i * j) + " ");
            j = j + 1;
        }
        document.write("<br>");
        i = i + 1;
    }   
};
f1();

// 给数组设置10个值，1-10
var f1 = function() {
    var arr = [];
    for(var i = 0;i < 10; i ++) {
        arr[i] = i + 1;
    }
    document.write(arr);
};
f1();

// 给数组设置10个值，2 4,6~20
var f2 = function() {
    var arr = [];
    for(var i = 0;i < 10;i ++) {
        arr[i] = 2*(i + 1);
    }
    document.write(arr);
};
f2();

//数组遍历求和
var sumArray = function(arr) {
    var sum = 0;
    for(var i = 0;i < arr.length; i ++) {
        sum += arr[i];
    }
    return sum;
};

//求整数数组的积
var jiArray = function(arr) {
    var ji = 1;
    for(var i = 0;i < arr.length;i ++) {
        ji *= arr[i];
    }
    return ji;
};
var f3 = function() {
    var arr = [1,2,3,4,5];
    var result = jiArray(arr);
    document.write(result);
}

// 传入整数数组，求所有偶数元素的和
var evenSum = function(arr) {
    var sum = 0;
    for(var i = arr.length;i -->0;) {
        if(arr[i] % 2 === 0) {
            sum += arr[i];
        }  
    }
    return sum;
};
var f4 = function() {
    var arr = [1,2,3,4];
    document.write(evenSum(arr));
};
f4();

//传入一个整数数组,把其中的偶数元素组装为新数组返回;
var abc = function(arr) {
    var newArr = [];
    var j = 0;
    for(var i = 0;i < arr.length;i ++) {
        if(arr[i] % 2 === 0) {
            newArr[j] = arr[i];
            j ++;
        }
    } 
    return newArr;
};
var f5 = function() {
    var arr = [1,2,3,4,5,6];
    document.write(abc(arr));
};

// 取arr数组的begin到end下标的元素，其中不包括end
var arraycopy = function(arr,begin,end) {
    var js = [];
    var j = 0;
    for(var i = begin;i < end;i ++) {
        js[j ++] = arr[i];
    }
    return js;
};

//查找整数数组中的最大值
var max = function(arr) { 
    var max = arr[0];
    for(var i = arr.length;i --> 1;) {
        if(arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
};
var max2 = function(arr) { //通过绑定下标 稍微好一点
    var maxIndex = 0;
    for(var i = arr.length;i --> 1;) {
        if(arr[i] > max) {
            maxIndex = i;
        }
    }
    return arr[maxIndex];
};

var hebin = function(arr1,arr2) {
    var newArr = [];
    for(var i= 0;i < arr1.length;i ++) {
        newArr[i] = arr1[i];
    }
    for(i = 0;i < arr2.length;i ++) {
        newArr[newArr.length] = arr2[i];
    }
    return newArr;
};

//[1,2,3,5,4] 找5返回下标3，如果没有找到则返回-1
var indexOf = function(arr,target) {
    for(var i = 0;i < arr.length;i ++) {
        if(arr[i] === target) {
            return i;
        }
    }
    return -1;
};

//[1,2,3,4,5] 把9插入下标1的位置 ---> [1,9,2,3,4,5]
var insert = function(arr,index,target) {
    arr[arr.length] = arr[arr.length - 1];
    for(var i = arr.length - 1;i --> 0;) {
        if(i === index) {
            arr[i] = target;
            break;
        }
        arr[i] = arr[i - 1];
    }
    return arr;
};
var xx = function() {
    var arr = [1,2,3,4,5,6];
    var target = 9;
    var index = 3;
    document.write(insert(arr, index, target));
};
xx();

//[1,2,3,4,5] 把x插入下标1的位置 ---> [1,x,2,3,4,5]
var insert = function(arr, index, target) {
    for(var i = arr.length;i --> index;) {
        arr[i + 1] = arr[i];
    }
    arr[index] = target;
    //[1,2,2,3,4,5]
    return arr;
};
var xx = function() {
    var arr = [1,2,3,4,5,6];
    var target = 9;
    var index = 3;
    document.write(insert(arr,index,target));
};
xx();

//[1,2,3,4,5] 删除数组中2这个元素 ---> [1,3,4,5]
var deleteAt = function(arr, index) {
    for(var i = index + 1;i < arr.length;i ++) {
        arr[i - 1] = arr[i];
    }
    //arr.length = arr.length - 1;
    arr.length --;
    return arr;
};
var testDeleteAt = function() {
    var arr = [1,2,3,4,5,6];
    var index = 3;
    document.write(deleteAt(arr, index));
};
testDeleteAt();

var grade = function(score) {
    var level = ["差","差","差","差","差","差","中","良","优"];
    return level[Math.floor(score/10)];
};
```

```
随机数
var v = Math.random(); //[0-1),包含0，不包含1

Math.abs(-4) = 4 //取绝对值
Math.max(1,2,3) = 3 //取最大值
Math.min(2,3,4) = 2 //取最小值

Math.floor(3.14) //地板 3
Math.floor(-3.14) // -4
Math.ceil(3.14) //天花板 4
Math.ceil(-3.84) // -3 
Math.round(3.14) //四舍五入 3

//返回0-100整数
var v = Math.floor(Math.random()*100);
//返回10-20之间的整数
Math.floor( Math.random()*10 ) + 10;
//返回a-b(a<b)的整数
Math.floor( Math.random()*(b-a) ) + a;
//返回a-b的整数,不知道a与b的大小
Math.floor(Math.random()*math.abs(a-b))+Math.min(a,b);
```

```
// 随机生成a-b之间的整数，不包括ab中的最大值
var randomAB1 = function(a,b) {
    return Math.floor(Math.random()*Math.abs(a-b))+Math.min(a,b);
};

//随机生成a-b之间的整数，包括a和b
var randomAB2 = function(a,b) {
    if(a > b) {
        return randomAB1(a+1, b);
    }else {
        return randomAB1(a, b+1);
    }
};
```

```
数组
	arr[arr.length] = 100; //在数组后面再添加一个数;
1)数组的常用操作
	a)遍历/过滤
    b)拷贝
    c)合并
    d)排序        平均时间复杂程度
        冒泡(稳定) 0(n^2)
        选择(稳定) 0(n^2)
        插入(稳定) 0(n^2)
        快速(不稳定) 0(n*log2n)
    e)打乱
    f)查找
    g)插入
    h)删除
    j)查表法
    h)随机数
```

```
字符串
1)字符串转化为伪字符数组
var s = "abc";
var arr = s.split(""); //["a","b","c"]
2)数组转换伪字符串
var arr = [1,2,3];
var str = arr.join("");//"123" 
3)split
var arr = "a-b1-c-d".split("-"); //["a","b1","c","d"];
var arr = "a-b1-c-d".split("-c"); //["a-b1","-d"];
4)join
var arr = [1,2,3];
var s = arr.join("-"); //1-2-3
5)charAt/charCodeAt
"abc".charAt(1); //b
"abc".charCodeAt(1); //98 返回对应数字的unicode码
6)indexOf/lastIndexOf
"abcd".indexOf("a"); //0
"abdcd".indexOf("d",3); //4 表示从做左到右第4位开始找
7)substr/substring
"abcdefg".substring(1,5); //bcde 包含第一位不包含第二位的
"abcdefg".substring(1,-1); //a
```

```
对象 
1)构造器
var Student = function(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.study = function() {

    };
};
var s1 = new Student("张三",18,male);
var s2 = new Student(10087,"李四",19,false);
2)删除属性
var obj = {
    age : 18;
}
delete obj.age;    
```

```
Date对象
1)构造器本身的new调用
	从1970年1月1日0:0:0开始计算
	var now = new Date();
```

```
17.数组对象的方法
a)concat 合并
        var arr1 = [1,2,3];
        var arr2 = ["a","b","c"];
        arr1 = arr1.concat(arr2);
b)join
c)pop 拉/push (栈结构,先进后出/后进先出)
		pop=删除并返回数组的最后一个元素
---------------------------------------------------
d)reverse 颠倒
			f = function() {
                var arr = [1,2,3];
                arr.reverse();
                alert(arr);
            };
e)shift 切换/unshift
		shift=删除并返回数组的第一个元素(删除头部)
		unshift=将参数们插入到数组的开始位置,它们在数组中的顺序与它们出现在参数列表中的顺序相同
		(在任意位置插入任意数量的元素)
f)slice 分割/splice 结合	
        f = function() {
            var arr = [1,2,3,4,5,6,7];
            var newArr = arr.silce(2,5); // [3,4,5]第二位开始不包括第五位
            newArr = arr.silce(2,-1); //[3,4,5,6];
            alert(newArr);
        };
	
	splice
            f = function() {
            var arr = [1,2,3,4,5,6];
            arr.splice(2,3); //从坐标是2开始往后删3个数
            alert(arr); //[1,2,6]
            arr.pop(); //[1,2]
            arr.push(3,4,5,6); //[1,2,3,4,5,6]
            arr.splice(2,3,"a","b"); //[1,2,"a","b",6] 在下标是2的位置开始往后删除3个数,然后再插入"a","b"
        };
g)sort排序
	arr.sort(fun)
	排序方法 有两个参数a,b
		如果a>b 返回>0
		如果a<b 返回<0
		如果a==b 返回0
			f = function() {
                var arr = [21,3,435,15];
                arr.sort(function() {
                    // if(a > b) {
                    //     return 1;
                    // }else if(a < b) {
                    //     return -1;
                    // }else {
                    //     return 0;
                    // }
                    return a - b; //升序
                })
            };
            alert(arr); //升序
        f = function() {
            var arr = [1,2,3,4,5,4];
            alert(arr.indexOf(4)); //3
            alert(arr.lastIndexOf(4)); //5
            alert(arr.lastIndexOf(4,4)); //3 找4,从第四位开始往前找
            alert(arr.indexOf(6)); //-1
        };
h)indexOf/lastIndexOf
```

```
19.dom概述
Node(节点)
	element(元素节点) == 1
	Text(文本节点) == 3
	Comment(注释节点) == 8
1)查找标签对象
	a)直接获取body和head
        window
        window.document === <html>
        window.document.body === <body>
        window.document.head === <head>
	b)通过标签的id属性值来查找
		var e = document.getElementById("idvalue");
	c)通过标签名称来查找
		var div_s = document.getElementsByTagName("div"); //获取网页中所有的div 
		var a_s = el.getElementsByTagName("a"); //el下的所有a标签
	d)通过class属性值来查找
		var box = document.getElementsByClassName("box");
	e)按照位置获取标签
        var childs = el.childNodes; //获取el下所有节点
        el.firstChild;
        el.lastChild;
        el.previousSibling;前兄弟
        el.nextSibling;
        el.parentNode;
	f)使用css选择器来进行标签查找
		var only = document.querySelector(""); //查找一个
		var nodelist = document.querySelectorAll(""); //查找多个
2)操作标签
	2.1)获取属性值
		var cls = e.getAttribute("class"); //获取标签的所有属性
		var cls = e.className; //获取标签本身拥有的属性
		注:针对class属性使用className来获取
--------------------------------------------------------------------------------
<body>
    <button class="btn111" type="submit" id="btn" xx="oo">ok</button>
    <script>
        var btn = document.getElementById("btn");
        var btnType = btn.getAttribute("type"); === btnType = btn.type;
        var btnId = btn.getAttribute("id"); === btnId = btn.id;
        var btnClass = btn.getAttribute("class"); === btnClass = btn.className; 
        											  //class是关键字所以写成className
        var xx = btn.getAttribute("xx");	//xx = btn.xx 这种获取不到自定义属性
        console.log(btnType + ":" + btnId + ":" + btnClass + ":" + xx);
    </script>
</body>
	2.2)改变属性值
		e.setAttribute("class","box xx");
		e.className = "box xx";
	2.3)添加/删除/测试拥有自定义属性
		e.xxx = value;
		e.setAttribute("xxx", value);
		delete e.xxx;
		e.removeAttribute("xxx");
		boolean = e.hasAttribute("xxx");
		改变标签内容
		e.innerHTML = "";
		e.tagName
		e.nodeType
	2.4)操作标签的样式
		div.style.backgroundColor = "red";
	2.5)调用方法
		//创建一个标签 node = document.creatElement("标签名称");
		//在el标签后面追加一个child子标签,返回新追加的子标签 child = el.appendChild(child);
		//在el的子标签中的whereChild的前面插入child子标签,返回新插入的子标签
			child = el.insertBefore(child,whereChild);
		//使用child替换whichChild; oldNode = el.replaceChild(whichChild,child);
		//删除child标签	child = el.removeChild(child)
		//克隆el节点,不包含标签内容 var newNode = el.cloneNode();
		//克隆el节点且包含el的所有子节点,包含标签内容	var newNode = el.cloneNode(true);
		//针对table
			var tr = table.insertRow(0);//0表示在最前面插,如果是-1或者不填则表示追加一行
			table.deleteRow(index);
			var tr = table.rows[index];
            var td = tr.insertCell();
            var td = tr.cells[index];
            tr.deleteCell();
	2.6)获取元素的位置
		相对于父元素的位置
        el.offsetTop(只读)
        el.offsetLeft(只读)
        el.offsetWidth
        el.offsetHeight 
	2.7)事件模型
        a)事件源
            使用event.target
            直接使用this
        b)事件类型(单击双击;右键单击左键单击;滚轮等鼠标事件;键盘事件;加载事件;关闭事件;)
            左键点击 click
            双击 dbclick
        c)事件处理方法
            方法参数为事件对象
            事件处理方法中的this,永远执行当前事件的事件源
        d)事件对象(event)
            事件对象里面包含事件发送时的所有数据信息
        e)事件监听添加
            1)使用标签对象进行事件注册
                ***写这个就好了
                el.addEventListener("事件类型",function(evt) {
                    //事件源
                    var target = evt.target;
                    //处理事件的代码
                });
            2)使用标签对象的属性
            btn.onclick = function() {

            };
            注:仅能绑定一个事件处理方法
            会有被覆盖的风险
-------------------------------------------------------------------------------
    <body>
        <button id="btn" onclick="alert(5);">ok</button>
        <script>
            var btn = document.getElementById("btn");
            btn.addEventListener("click", function() {
                alert(1);
            });
            var handlerBtnClick2 = function() {
                alert(2)
            };
            btn.addEventListener("click",handlerBtnClick2);
            //删除
            btn.removeEventListener("click",handlerBtnClick2);
            btn.onclick = function(evt) { 
            	//是给btn的onclick属性赋值,下面的值会覆盖上面的值,所以只会执行一次
                evt = evt || window.event; //兼容性,兼容IE
                alert(3);
            };
            btn.onclick = function(evt) {
                evt = evt || window.event;
                alert(4);
            };
        </script>
    </body>
	3)在标签上绑定
		<button onclick ="alert(1);"></button>
		注:此种方式和第二种是一样的
	f)事件监听删除
		el.removeEventListener("事件类型",事件处理方法引用);
    g)键盘事件
        1)事件类型
            keydown(针对所有按钮)
            keyup
            keypress(仅针对字母和数字)
        2)evt.keyCode
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title>图片切换</title>
   </head>
   <body>
      <button id="btn1">点我切换图片</button>
      <img id="img1" src="./1.jpg" alt="" width="300px" height="300px">
      <script>
         var btn1 = document.getElementById("btn1");
         var img1 = document.getElementById("img1");
         var i = 1;
         btn1.addEventListener("click", function() {
            img1.src = "./" + (i % 3 + 1) + ".jpg";
            i ++;
         })
      </script>
   </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title></title>
   </head>
   <body>
      <button id="btn">1</button>
      <script>
         // 不适用外部变量,避免死机以及太耗内存,用事件源就可以解决
         var btn = document.getElementById("btn");
         btn.addEventListener("click", function(evt) {
            var target = this;
            var v = parseInt(target.innerHTML, 10);
            btn.innerHTML = String(++v);

            // var target = evt.target;
            // var v = parseInt(target.innerHTML, 10);
            // btn.innerHTML = String(++v);
         })
      </script>
   </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title>每次点击图片放大10%</title>
   </head>
   <body>
      <img id="img" src="./1.jpg" alt="" width="30px" height="30px">
      <script>
         var img = document.getElementById("img");
         img.addEventListener("click", function() {
            this.height *= 1.1;
            this.width *= 1.1;
         })
      </script>
   </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title></title>
   </head>
   <body>
      <img id="img" src="./1.jpg" alt="" width="30px" height="30px">
      <script>
         var img = document.getElementById("img");
         setInterval(function() {
            img.height += 1;
            img.width += 1;
         },10)
      </script>
   </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title></title>
   </head>
   <body>
      <!-- 容器 -->
      <div id="box"></div>
      <hr>
      <button id="addBtn">添加</button>
      <button id="delBtn">删除</button>
      <button id="cloneBtn">克隆</button>
      <script>
         // querySlectorAll 找出所有匹配的节点并返回数组,如果没有则返回空的nodelist
         // querySlector 找到一个后就返回节点对象
         var box = document.getElementById("box"); //获取到容器dom节点
         var addBtn = document.querySelector("#addBtn"); //获取到添加按钮dom节点
         var delBtn = document.querySelector("#delBtn"); //获取到删除按钮dom节点
         var cloneBtn = document.querySelector("#cloneBtn"); //获取到克隆按钮dom节点
         var i = 1;
         addBtn.addEventListener("click", function() {
            var btn = document.createElement("button"); //创造
            btn.innerHTML = String(i ++); //灵魂
            box.appendChild(btn); //添加
         })
         delBtn.addEventListener("click", function() {
            var lastChild = box.lastChild; //找到最后一个元素
            box.removeChild(lastChild); //移除最后一个元素
         })
         cloneBtn.addEventListener("click", function() {
            var lastChild = box.lastChild;
            box.appendChild(lastChild.cloneNode(true));
         })
      </script>
   </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title>1.九九乘法表</title>
      <style>
         table,td{
            border: 1px solid black;
         }
      </style>
   </head>
   <body>
      <script>
         var table = document.createElement("table");
         document.body.appendChild(table);
         for(var i = 1;i < 10;i ++) {
            var tr = document.createElement("tr");
            table.appendChild(tr);
            for(var j = 1;j < 10;j ++) {
                var td = document.createElement("td");
                td.innerHTML = String(i * j);
                tr.appendChild(td);
            }
        }
      </script>
   </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
   <head>
      <meta charset="UTF-8">
      <title>2.九九乘法表</title>
      <style>
         table,td{
            border: 1px solid black;
         }
      </style>
   </head>
   <body>
      <script>
         // insertRow()方法用于在表格中的指定位置插入一个新行
         // insertCell()方法用于在html表的一行的指定位置插入一个空的<td>元素
         var table = document.createElement("table");
         document.body.appendChild(table);
         for(var i = 1;i < 10;i ++) {
            var tr = table.insertRow(); //插入9行
            for(var j = 1;j < 10;j ++) {
               var td = tr.insertCell(); //每一行挖9个坑
               td.innerHTML = String(i * j); //往9行9个坑里填81个数
            }
         }
         // i=1   j=1,=2,=3,=4,=5,=6,=7,=8,=9
         // i=2   j=1,=2,=3,=4,=5,=6,=7,=8,=9
         // i=3   j=1,=2,=3,=4,=5,=6,=7,=8,=9
         // ...
      </script>
   </body>
</html>
```

```
小方块运动:
var div = document.createElement('div');
document.body.appendChild(div);
div.style.width = "100px";
div.style.height = "100px";
div.style.backgroundColor = "red";
div.style.borderRadius = "50%";
div.style.position = "absolute";
div.style.top = "0";
div.style.left = "0";
var speed = 1;
var timer = setInterval(function() { //定时器
	speed += speed/50;
	//div.style.left是字符串形式,需要取整转换为number再进行操作
    div.style.top = parseInt(div.style.top) + speed + "px";
    div.style.left = parseInt(div.style.left) + speed + "px";
    if(parseInt(div.style.top) > 400 && parseInt(div.style.left) > 400) {
        clearInterval(timer);
    }
},30); 
-------------------
键盘操纵小方块运动:
<script>
var div = document.createElement('div');
document.body.appendChild(div);
div.style.width = "100px";
div.style.height = "100px";
div.style.backgroundColor = "red";
div.style.position = "absolute";
div.style.top = "0";
div.style.left = "0";
document.onkeydown = function(e) {
	switch(e.which) {
		case 37: //左
            div.style.left = paeseInt(div.style.left) - 5 + "px";
            break;
        case 38: //下
        	div.style.top = paeseInt(div.style.top) - 5 + "px";
        	break;
        case 39: //右
        	div.style.left = paeseInt(div.style.left) + 5 + "px";
        	break;
        case 40: //上
        	div.style.top = paeseInt(div.style.top) + 5 + "px";
        	break;
	}
}
--------------------
不断滑动颜色会变浅:
*{
    margin: 0;
    padding: 0;
    list-style: none;
}
li{
    box-sizing: border-box;
    float: left;
    width: 10px;
    height: 10px;
    border: 1px solid black;
}
ul{
    width: 200px;
    height: 200px;
}
<body>
	<ul>
		<li img-data="0"></li> *400
	</ul>
<script>
	var ul = document.getElementsByTagName('ul')[0];
	ul.onmouseover = function(e) {
        var event = e || window.event;
        var target = event.target || event.srcElement; //兼容性处理
        target.style.backgroundColor = "rgb(0,255," + target.getAttribute('img-data') +")";
        target.setAttribute('img-data', parseInt(target.getAttribute('img-data')) + 9);
	}
查看元素节点:
a. document.getElementsByTagName();
b. document.getElementsByClassName(); //IE8和IE8以下版本没有,可以多个class连着一起使用
c. document.getElementById(); //元素id在IE8以下的浏览器,不区分大小写
d. document 代表整个文档
e. document.getElementsByName(); //只有部分标签的name可生效 (表单,表单元素,img,iframe)
f. querySlectorAll(); //css选择器,镜态,不实时更新,类似照片,在IE7及以下版本中没有,H5新增
g. querySlector //css选择器,镜态,不实时更新,类似照片,在ie7和ie7以下的版本中没有,了解即可
---------------------------------------------------------------------------------
遍历节点树:
a. parentNode ---> 父节点,最顶端的parentNode为#document
b. childNodes ---> 子节点们,包含文本节点
c. firstChild ---> 第一个子节点
d. lastChild ---> 最后一个子节点
e. nextSibling ---> 后一个兄弟节点 
f. previousSibling ---> 前一个兄弟节点
------------------------------------------------------
<div>
	<strong></strong>
	<span></span>
</div>
var strong = document.getElementsBytagName('strong')[0];
strong.parentNode;
--------------------------------------------------------
基于元素节点树的遍历:
a. parentElement ---> 返回当前元素父元素的节点(IE不兼容)
b. children ---> 返回当前元素的子节点
c. node.childElementCount === node.children.length 当前元素节点的子元素节点个数(IE不兼容)
d. firstElementChild ---> 返回第一个元素节点(IE不兼容)
e. lastElementChild ---> 返回最后一个元素节点(IE不兼容)
f. nextElementSibling / previousElementSibing ---> 返回后一个/前一个兄弟元素
--------------------------------------------------------------------------
节点类型: ---> 调用nodeType返回数值
a)元素节点   1
b)属性节点   2
c)文本节点   3
d)注释节点   8
e)document  9
f)DocumentFragment  11
-------------------------------
节点的四个属性:
a)nodeName
	元素的标签名,以大写形式表示,只读
b)nodeValue
	Test节点或Comment节点的文本内容,可读写
*c)nodeType
	该节点的类型,只读
d)attributes
	Element节点的属性结合
--------------------------
节点的一个方法: 
Node.hasChildNodes();
document --原型--> HTMLDocument.prototype --原型--> Document.prototype
---------------------------------------------------------------
document.documentElement --指代--> html
document.body --指代--> body
document.head --指代--> head
-------------------------------------------------------------------
1.getElementById方法定义在Document.prototype上,即Element节点上不能使用;
2.getElementsByName方法定义在HTMLDocument.prototype上,即非html中的document不能使用(xml document,Element);
3.getElementsByTagName方法定义在Document.prototype和Element.prototype上;
4.HTMLDocument.prototype定义了一些常用的属性,body,head分别指代HTML文档中的<body><head>标签;
5.Document.prototype上定义了documentElement属性,指代文档的根元素,在HTML文档中,指代<html>元素;
小测试:
1.遍历元素节点树 (在原型链上编程);
------------------------------------
2.封装函数,返回元素e的第n层祖先的元素节点;
    <div>
        <strong>
            <span>
                <i></i>
            </span>
        </strong>
    </div>
    function retParent(elem, n) {
        while(elem && n) { //容错处理,elem必须有意义,即elem为null时停止
            elem = elem/parentElement;
            n --;
        }
        return elem;
    }
    var i = document.getElementsByTagName('i')[0];
---------------------------------------------------------------------------------------
3.封装函数,返回元素e的第n个兄弟元素节点,n为正,返回后面的兄弟元素节点;n为负,返回前面的;n为0,返回自己;
    function retSibling(e, n) {
        while(e && n) {
            if(n > 0) {
                e = e.nextElementSibling; //ie9以下不能使用
                n --;
            }else {
                e = e.nextElementSibling;
                n ++;
            }
        }
        return e;
    }
------------------------------------------------
4.封装myChildren功能,解决以前部分浏览器的兼容性问题;
    //找该元素的子元素节点
    //如何区分元素节点和非元素节点
    Element.prototype.myChildren = function() {
        var child = this.childNodes;
        var len = child.length;
        var arr = [];
        for(var i = 0;i < len; i ++) {
        if(child[i].nodeType == 1) {
            arr.push(child[i]);
            }
        }
        return arr;
    }
-------------------------------------------------
5.封装hasChildren()方法,不可用children属性;
    Element.prototype.myChildren = function() {
        var child = this.childNodes;
        var len = child.length;
        var arr = [];
        for(var i = 0;i < len; i ++) {
        if(child[i].nodeType == 1) {
            return true;
            }
        }
        return false;
    }
元素节点的增加 插入 删除 替换
-------------------------
增加:
a)document.createElement(); 创建元素节点
	var div = document.createElement('div');
	document.body.appendChild(div);
b)document.createTextNode(); 创建文本节点
c)document.createComment(); 创建注释节点
-----------------------------------------
插入:
appendChild();
insertBefore(a, b);
-----------------
<div></div>
var div = document.getElementsByTagName('div')[0];
var text = document.createTextNode('邓宝宝');
var span = document.createElement('span');
div.appendChild(text); 
div.appendChild(span);
var text1 = document.createTextNode('demo');
span.appendChild(text1); //appendChild类似于剪切的功能
span.appendChild(text);
----------------------------------------------------------------------------
ParentNode.insertBefore(a, b); //父级调用,往父级里面插元素,在最前面插入元素
eg: div.insertBefore(a, b); //div insert A before B; insert第一个before第二个
----------------------------------------------------------------------------
删除:
parent.removeChild(); //实质上是剪切,并不是真的删除
child.remove(); //真的是删除
----------------------------
替换:
parent.replaceChild(new,origin); //拿新的元素替换老的元素,老的元素也是被剪切了
------------------------------------------------------------------------
Element节点的属性:
	innerHTML
	innerText(火狐不兼容)/textContent(老版本IE不好使) 不会管标签,把文本都取出来
------------------------------------------------------------------------
Element节点的方法:
	ele.setAttribute(); 设置行间属性
	ele.getAttribute(); 得到行间属性
---------------------------------
<div><div>
div.innerHTML = '123';
div.innerHTML += '456'; 后面追加数字
div.innerHTML = "<span style="color:#fff;font-size:20px">123</span>";
----------------------------------------------------------------------
练习:
1.封装函数insertAfter();功能类似insertBefore();
提示:可忽略老版本浏览器,直接在Element.prototype上编程;
    Element.prototype.insertAfter = function(targetNode, afterNode) {
        var beforeNode = afterNode.nextElementSibling;
        if(beforeNode == null) {
            this.appendChild(targetNode);
        }else {
            this.insertBefore(targetNode.beforeNode);
        }
    }
---------------------------------------------------------------------------
2.将目标节点内部的节点顺序逆序; 用appendChild,思路:先把倒数第二个放到最后,..逐渐往下移
eg: <div><a></a><em></em></div>
----> <div><em></em><a></a></div>
日期对象 Date
var date = new Date;
Date(); //返回当前的日期和时间
date.getDate(); //一个月里的第几天
date.getDay(); //一周里的第几天,星期天是第一天
date.getMonth(); //返回月份(0-11),我们使用的时候要 + 1;
date.getFullYear(); //返回年份;
getHours();
getMinutes();
getSeconds(); //这里记录的都是new出来的对象那一刻的时间,不会变化;
getMilliseconds(); //返回毫秒
getTime(); //返回1970年1月1日至今的毫秒数;
var firstTime = new Date().getTime();
for(var i = 0;i < 1000000; i ++) {
	//运行了多久啊
}
var lastTime = new Date().getTime();
console.log(lastTime - firstTime);
--------------------------------------
类似闹钟:
var date = new Date(); //获取当前时间
setInterval(function() {
    if(new Date().getTime() - date.getTime() > 3000) { //过了3秒的话
        console.log('时间到了'); //打印一下
    }
},1000);
--------------------------------------
封装函数,打印当前是何年何月何日何时几分几秒？
js定时器:
setInterval(); 非常不准,循环执行
setTimeout(); 延迟执行,执行一次
clearInterval();
clearTimeout();
-----------------------------------------
全局对象window上的方法,内部函数this指向window
注意: setInterval(“func()”,1000);
---------------------------------
var i = 0;
setInterval(function() {
    i++;
    console.log(i);
},1000);
-------------------------------------
var i = 0;
var timer = setInterval(function() {
    console.log(i ++);
    if(i > 10) {
        clearInterval(timer);
    }
}, 1000);
--------------------------------------
var timer = setTimeout(function(){
    console.log('a');
}, 1000);
clearTimeout(timer);
------------------------------------
写一个定时器:
input{
    border: 1px solid rgba(0,0,0,0.1);
    text-align: right;
    font-size: 20px;
    font-weight: bold;
}
minutes:<input type="text" value="0">
seconds:<input type="text" value="0">
var minutesNode = document.getElementsByTagName('input')[0],
	secondsNode = document.getElementsByTagName('input')[1],
	minutes = 0,
	seconds = 0;
var timer = setInterval(function() {
    seconds ++;
    if(seconds == 60) {
        seconds = 0;
        minutes ++;
    }
    secondsNode.value = seconds;
    minutesNode.value = minutes;
    if(minutes == 3) {
        clearInterval(timer);
    }
}, 1000);
查看滚动条滚动距离:
window.pageXOffset/pageYOffset ie8及以下不能使用
document.body.scrollLeft === documentElement.scrollLeft/scrollTop ie8以下这两个有效
-----------------------------------------------------------------------------------
封装兼容性方法,求滚动轮滚动距离 getScorollOffset();
function getScrolloffset() {
    if(window.pageXoffset) {
        return {
            x : window.pageXoffset,
            y : window.pageYoffset,
        }
    }else {
        return {
            x : document.body.scrollLeft + document.documentElement.scrollLeft,
            y : document.body.scrollTop + document.documentElement.scrollTop
        }
    }
}
查看视口的尺寸:
window.innerWidth/innerHeight (IE8及IE8以下不兼容)
document.documentElement.clientWidth/clientHeight //标准模式下,任意浏览器都兼容
document.body.clientWidth/clientHeight //适用于怪异模式下的浏览器
-------------------------------------------------
封装兼容性方法,返回浏览器视口尺寸getViewportOffset();
function getViewportOffset() {
    if(window.innerWidth) {
        return {
            w : window.innerWidth,
            h : window.innerHeight
        }
    }else {
        if(document.compatMode === "BackCompat") {
            return {
                w : document.body.clientWidth,
                h : document.body.clientHeight
            }
        }else {
            return {
                w : document.documentElement.clientWidth,
                h : document.documentElement.clientHeight
            }
        }
    }
}
查看元素的几何尺寸 (了解即可)
domEle.getBoundingClientRect();
兼容性很好,该方法返回一个对象,对象里面有left,top,right,bottom等属性,left和top代表该元素左上角的X和Y坐标,right和bottom代表元素右下角的X和Y坐标,height和width属性老版本IE并未实现,返回的结果并不是实时的;
-----------
查看元素的尺寸 (视觉上的尺寸)
dom.offsetWidth/dom.offsetHeight
查看元素的位置 (当前元素距离自己有定位的父级的距离)
dom.offsetLeft/dom.offsetTop 对于无定位父级的元素,返回相对文档的坐标;对于有定位父级的元素,返回相对于最近的有定位的父级的坐标;
dom.offsetParent 返回最近有定位的父级,如无则返回body,body.offsetParent返回null
eg: 求元素相对于文档的坐标 getElementPosition
-------------------------------------------
脚本化CSS
div.style.backgroundColor = "green";
只能在行间样式上进行添加的才能识别,没有兼容性问题,碰到float这样的保留字属性,前面应加css
eg:div.style.cssFloat
-----------------------------------
查询计算样式
window.getComputedStyle(ele,null); //这里第二个参数是填写伪类选择器时候使用的
window.getComputedStyle(div,null).width
计算样式只读
返回的计算样式的值都是绝对值,没有相对单位
IE8及IE8以下不兼容
------------------------------------
查询样式
ele.currentStyle
计算样式只读
返回的计算样式的值不是经过转换的绝对值
IE独有的属性
封装兼容性方法getStyle(elem,prop);
function getStyle(elem, prop) {
    if(window.getComputedStyle) {
        return window.getComputedStyle(elem, null)[prop];
    }else {
        return elem.currentStyle[prop];
    }
}
```

```
ctrl + d 选中同类型的代码块;
ctrl y 和 ctrl z 作用相反;
作用域
1.运行期上下文: 当函数执行前一刻,会创建一个称为执行期上下文的内部对象。
执行期上下文定义了该函数执行时的环境,函数每次执行时对应的执行期上下文都是独一无二的,所以多次调用
同一个函数会创建多个执行上下文,当函数执行完毕,它所产生的执行上下文立即被销毁;
2.查找变量: 在当前函数,从作用域链的顶端依次向下查找;
3.一个函数刚刚出生的时候,[[scope]]作用域里面就已经存了GO,当函数执行的时候又会产生执行期上下文AO,
并且将AO放在作用域链的最顶端;
4.每一个函数都有一个执行期上下文的集合,叫作用域链。
我们真正在这个函数里面去访问某一变量的话要遵循这个函数的作用域链按顺序去访问;
5.一个函数执行完之后是要销毁自己本身的执行期上下文的,b只会干掉自己本身所产生的AO;但是a不一样,
当a执行结束后去除作用域链(scope chain)和自己本身的AO的联系线的时候,因为a里面的AO是包含b函数的
(b : function),所以b就会永远没有了,a重新回归未定义状态,等待下一次被执行;
6.一切对象都有属性。函数也是一种特殊的对象,叫函数类对象,也有自身的属性,有些属性可以访问,有些则不能:
    a.function test() {}
          test.name 
          test.prototype //我们可以访问的属性
	b.我们不能访问的属于隐式属性,这些属性仅供javascript引擎存取,[[scope]]就是其中之一
		  [[scope]] 指的就是我们所说的作用域,其中存储了运行期上下文的集合;
		  test.[[scope]], [[scope]]表示由这个函数所产生的作用域
7.作用域链: [[scope]]中存储的是执行期上下文对象集合,这个集合呈链式链接;
我们把这种链式链接叫做作用域链。
例子:
function a() { //a刚出生,是在全局下去看世界
    function b() { //由于a执行产生b定义,所以b刚出生时的执行期上下文是a的最终结果;
    b是站在a的肩膀上去看世界,b里面产生的类似a产生的AO其实质就是a自身所产生的AO;
        var b = 234;
    }
    var a = 123;
    b(); //当b执行的时候,产生自身的AO又会跑到执行期上下文的最上面
}
var glob = 100;
a();
图解:
function a() {
    function b() {
        function c() {
            
        }
        c();
    }
    b();
}
a();
----------------------------------
            作用域        执行期上下文
a defined a.[[scope]] --> 0 : GO
a doing   a.[[scope]] --> 0 : aAO
						  1 : GO

b defined b.[[scope]] --> 0 : aAO
						  1 : GO
b doing   b.[[scope]] --> 0 : bAO
						  1 : aAO
						  2 : GO

c defined c.[[scope]] --> 0 : bAO
						  1 : aAO
						  2 : GO
c doing   c.[[scope]] --> 0 : cAO
						  1 : bAO
						  2 : aAO
						  3 : GO
立即执行函数
js 给我们提供的唯一一个能立即销毁函数的方式就是立即执行函数;
定义: 此类函数没有声明,在一次执行过后即释放,适合做初始化工作。
写法:
	1. (function() {}()); *w3c建议使用
	2. (function() {})(); 
	当括号把function() {}函数声明包围起来的时候,就变成一个表达式,所以能被执行符号(),立即执行
a) 只有表达式才能被执行符号()所执行;
    var test = function() {
        console.log('a');
    }() //能够被执行

    + function test() {
        console.log('a');
    }() // + 使得函数声明变成一个表达式,即可以被执行,执行后函数名test就找不到了,相当于立即执行函数
    - function test() {
        console.log('a');
    }() //同理
    ! function test() {
        conosle.log('a');
    }() //同理
b) 能被执行符号执行的表达式,这个函数的名字就会被忽略 === 相当于立即执行函数
c) 立即执行函数是针对初始化功能的函数;
    ()
    (function() {})
    (function() {}())
    (function(a, b, c) {}(1, 2, 3)) //a,b,c是形参;1,2,3是实参
    var num = (function(a, b, c) { //立即执行函数也可以有返回值
        var d = a + b + c;
        return d;
    }(1, 2, 3))
    (function() { //只被执行一次就销毁了
        var a = 123;
        var b = 234;
        console.log(a + b);
    }())
d)
function a() {
    function b() {
        var bbb = 234;
        console.log(aaa); //124
    }
    var aaa = 124;
    return b; 
    //把b保存到外面去了,即a执行所返回的结果是函数b的引用,demo存完函数b之后a才算真正执行完
}
var glob = 100;
var demo = a();
demo(); //124 执行demo,相当于在外部执行函数b

闭包: 内部的函数被保存到了外部,一定形成闭包;
(内部函数一定会保存外部函数的劳动成果,保存完成之后并没有被执行,而是直接被扔到了外部,依旧保存着
外部函数已被销毁的AO);
闭包会导致原有作用域链不释放,造成内存泄露; ---> (内存越来越少)
闭包的作用:
1.实现公有变量;
	eg:函数累加器
2.可以做缓存(存储结构);
	eg:eater
3.可以实现封装,属性私有化;
	eg:Person()
4.模块化开发,防止污染全局变量;
函数累加器就是用闭包来实现的,不依赖于外部变量,实现函数的累加效果;
    function add() {
        var count = 0;
        function demo() {
            count ++;
            console.log(count);
        }
        return demo; //让demo保存add的劳动成果,所以demo外面定义的变量就能随便用了
    }
    var counter = add();
存储结构:
    function eater() {
        var food = "";
        var obj = {
            eat : function() {
            	console.log("food is" + " " + food);
                console.log("I am eating" + " " + food);
                food = "";
                console.log("now,food is" + " " + food);
            },
            push : function(myFood) {
                food = myFood;
            }
        }
        return obj;
    }
    var eater1 = eater();
function test() {
    var num = 100;
    function a() {
        num ++;
        console.log(num); //因为a里面没有定义num,所以就会去上一层去找num属性并且修改并且保存
    }
    function b() {
        num --;
        console.log(num); //因为b里面没有定义num,所以就会去上一层去找num属性,即a函数执行修改完之后的num的值进行运算
    }
    return [a,b]; //a和b使用的是父级的同一个AO,他们连的线都是test的劳动成果,所以操作的是同一个对象
}
var myArr = test();
myArr[0](); //101
myArr[1](); //100
function a() {
    var num = 100;
    function b() { //b是拿得到a里面的变量的,b刚刚被定义的时候拿的是a的劳动成果,死死地绑在了自己的身上,b每次执行的时候都在自己的执行上下文上形成一个新的AO,执行完成之后把自己的AO扔掉,等下次执行的时候再创建一个新的自己的AO,
        num ++; //去a的AO里面拿num,变成101
        console.log(num);
    }
    return b;
}
var demo = a();
demo(); //101 相当于执行一次b
demo(); //102 由于b的AO里面没有所要打印的num,所以我们还是去a的AO里面找num,进行操作
function test() {
    var arr = [];
    for(var i = 0;i < 10;i ++) {
        arr[i] = function() {
            document.write(i + " ");
        }
    }
    return arr;
}
var myArr = test();
for(var j = 0;j < 10;j ++) {
    console.log(myArr[j]()); //输出10个10
}
步骤:
一开始进来定义一个空数组用来存放值,for循环10次,*每次把声明函数function() {document.write(i + "")}赋给arr[i],其中i是会随着for循环递增的,声明函数里是不会解读的,只有在下面执行函数时候计算机才会去查看声明函数里面的代码,即把一个同样的声明函数function() {document.write(i + "")}作为整体,赋给arr[i],arr[i]中i递增,直到return arr;那么现在数组arr里面有10个相同的声明函数均为function() {document.write(i + "")},*注意结束for循环后的i已经变为10了,下面为了简化函数执行,也是采用了for循环,即将执行函数赋予给数组myArr,使用for循环去执行10次上面的test函数,自然输出的是10个10了,因为在执行前一刻i已经是10了。
---------------------------------------------------------------------------------------
解决措施:
function test() {
    var arr = [];
    for(var i = 0;i < 10;i ++) {
        (function(j) { //使用立即执行函数去实现上面我们想要看到的效果,即打印出0 1 2 3...其中形参j
            arr[j] = function() { //传入形参j
                console.log(j + ""); //传入形参j进行形参统一
            } 
        }(i)); //实参i   *为什么会想到用立即执行函数,因为立即执行函数在闭包中会保留父级的AO,并且执行结束就被立刻销毁
    }
    return arr;
}
var myArr = test();
for(var j = 0;j < 10;j ++) {
    myArr[j]();
}
//在最后执行的时候,之前循环出来的会去自身之前没有销毁时候所继承的父级的AO里面找对应的j的值并打印出来;
(function(j) {
    //j = 0;
    arr[j] = function() {
        console.log(j + "");
    }
})
(function(j) {
    //j = 1;
    arr[j] = function() {
        console.log(j + "");
    }
})
...注意最后打印出来的i依旧是10,但是我们设置立即执行函数里面打印的是j,相当于立即执行函数中的形参j每次都在递增,然后立即执行函数立即被销毁,但是在销毁的时候return出去的函数声明依旧连线对应父级的AO,依旧找到是自己这一轮循环层中的已经被销毁的父级AO里j的值,已经牢牢的被抓住了;
闭包
定义: 当内部函数被保存到外部时,将会生成闭包。闭包会导致原有作用域链不释放,造成内存泄露。
												  (过多占用内存资源叫内存泄露)
触发闭包:
	1.存在两个函数互相嵌套;
	2.把里面的函数保存到了外部,即保存到了全局;
	3.里面函数在外面执行的时候,一定能够调用的了原来包含他的函数里面的变量;
	4.里面的函数被保存到了外面函数的外部,即全局,就一定会形成闭包。里面的函数会保存外面函数的劳动成果;
function test() {
    var temp = 100;
    function a() {
        console.log(temp); //能够调用包含他的外一层函数里面的变量,因为已经继承了test的AO和GO
    }
    return a; //这里直接把函数内的函数return到了全局下
}
var demo = test();
demo();
var demo;
function test() {
    var abc = 100;
    function a() {
        console.log(abc);
    }
    demo = a;
}
test();
demo();
//里面函数活的比外面基础函数还要长,并且继承了外面函数的AO,GO,那么他就会产生不寻常的效果;
练习:
2.Display的参数值及其含义？
    none 此元素不会被显示
    block 此元素将显示为块级元素,此元素前后会带有换行符
    inline 默认,此元素会被显示为内联元素,元素前后没有换行符
    inline-block 行内块元素
    list-item 此元素会作为列表显示
    inherit 规定应该从父元素继承display属性的值
3.position属性有哪些值,有什么区别？
position的四个属性:
a.relative: 生成相对定位的元素,通过top,bottom,left,right的设置相对于其正常(原先本身)位置进行定位,可通过z-index进行层次分级;(不会脱离文档流,相对于自己在文档流中的初始位置偏移定位)
b.absolute: 生成绝对定位的元素,相对于static定位以外的第一个父元素进行定位,元素的位置通过"left","top","right","bottom"属性进行规定,可通过z-index进行层级划分;(会脱离文档流,相对于父级非position:static浏览器定位)
c.fixed: 生成绝对定位的元素,相对于浏览器窗口进行定位,元素的位置通过"left","top","right","bottom"属性进行规范,可通过z-index进行层次分级;(会脱离文档流,相对于浏览器窗口进行定位)
d.static: 默认值,没有定位,元素出现在正常的流中(忽略top,bottom,left,right或者z-index声明);
4.
<ul>
	<li>a</li>
	<li>a</li>
	<li>a</li>
	<li>a</li>
</ul>
<style type="text/css">
	*{
        margin: 0;
        padding: 0;
	}
	ul{
        list-style: none;
	}
	li:nth-of-type(2n) { //偶数
        background-color: red;
	}
	li:nth-of-type(2n+1) { //奇数
        background-color: green;
	}
</style>
使用原生js,addEventListener,给每一li元素绑定一个click事件,输出他们的顺序？
(表面是考绑定监听事件,实际考的是闭包问题。以后但凡我们需要索引的情况下,都是需要使用闭包去解决问题的)
<script>
	function test() {
        var liCollection = document.getElementsByTagName('li');
        for(var i = 0;i < liCollection.length;i ++) {
            (function(j) {
                liCollection[j].onclick = function() {
                    console.log(j);
                }
            }(i))
        }
	}
	test();
</script>
5.写一个方法,求一个字符串的字节长度;
(提示: 字符串有一个方法charCodeAt(); 一个中文占两个字节,一个英文占一个字节);
定义和用法: charCodeAt()方法可返回制定位置的字符的Unicode编码,这个返回值是0-65535之间的整数;
(当返回值 <= 255时为英文,字节是1; 当返回值 > 255时为中文,字节是2);
语法: stringObject.charCodeAt(index);
eg:
<script>
	var str = "Hello world";
	document.write(str.charCodeAt(1)); //输出101, 索引从第0位开始
</script>
-------------------------------------------------
输出字符串所占字节数
function retByteslen(target) {
    var count = 0; //初始化值
    for(var i = 0;i < target.length;i ++) {
        if(target.charCodeAt(i) <= 255) { //英文占一个字节
            count ++;
        }else if(target.charCodeAt(i) > 255) { //中文占两个字节
            count += 2;
        }
    }
    console.log(count);
}
---------------------------简化版
思想:英文是占1个字节,中文是占2个字节,所以我们先把所有都当做英文字节,然后遍历出有几个中文字节,再在基础上加1
function retByteslen(target) {
    var count = target.length; //所有都当做英文字节来操作;
    for(var i = 0;i < target.length;i ++) {
        if(target.charCodeAt(i) > 255) { //遍历有几个中文字节
            count ++; //在之前count的基础上进行增加效果
        }
    }
    console.log(count);
}
--------------------再简化,简化for循环里面的数组长度,因为她是一个定值不会变化的
function retByteslen(target) {
    var count,
    	len;
    	count = len = target.length;
    for(var i = 0;i < len;i ++) {
        if(target.charCodeAt(i) > 255) {
            count ++;
        }
    }
    console.log(count);
}
---------------------------
6.写出下面程序的执行结果:
var x = 1;
if(function f() {}) { //因为function f() {}在()括号里,所以就变成了表达式,她就不是函数定义了,f从此之后就消失了,未经声明的变量只有放到typeof里面才不报错
    x += typeof f; //typeof f返回的是字符串类型的undefined
}
console.log(x);
逗号运算符,会把后面的结果返回出去
var a = (1 - 1, 1 + 1); ---> 2
写出下面程序的执行结果
var f =(
	function f() {
        return "1";
	}, //有逗号运算符返回后面的
	function g() {
        return 2;
	}
)();
typeof f;
对象
1.对象是一种基础变量类型,和数组以及函数function都属于引用值;
2.对象属性的增、删、改、查;
    增 mrDeng.wife = "xiaoliu";
    删 delete mrDeng.name; (借助delete操作符)
    改 mrDeng.sex = female;
    查 mrDeng.sex;
3.对象的创建方法;
a)字面值:
	1.var obj = {}; plainObject 对象字面量/对象直接量
b)构造函数:
	1.系统自带: 
		new Object(); Array(); Number(); Boolean(); String(); Date();
	2.自定义:
	3.Object.create(原型)方法
---------------------------------------
1.
var obj = new Object(); 
//这个Object函数是系统自带的构造函数,通过new + 系统自带的构造函数能够产生一个对象;
2.
//小驼峰式命名规则是除了首个单词的首字母小写以外,后面位数单词的首字母都要大写;
//构造函数命名规则严格按照: 大驼峰式命名规则 (每个单词首字母都大写)
function Person() {} //Person首字母大写
var person1 = new person();
-------------------------------
function Car(color) { //通过给形参设定为自定义的选项,可以达到模板里面可选择变化项的实现
	this.color = color; //color可以灵活自定义
    this.name = "BMW";
    this.height = "1400";
    this.lang = "4900";
    this.weight = 1000;
    this.health = 100;
    this.run = function() {
        this.health --;
    }
}
var car = new Car(‘red’);
var car1 = new Car('green'); //car和car1彼此独立
------------------------------------------------------
function Student(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    this.grade = 2017;
}
var student = new Student('zhangsan', 18, 'male');
--------------------------------------------------------
当一个对象的属性没有的时候就访问是会打印 undefined
var mrDeng = {
    name : "MrDeng",
    age : 40,
    sex : "male",
    health : 100,
    smoke : function() {
        console.log('I am smoking! cool!!!');
        this.health --;
    },
    drink : function() {
        console.log('I am drinking!');
        this.health ++;
    },
}
//调用属性 mrDeng.health
//改变属性 mrDeng.health ++
//调出函数引用 mrDeng.smoke
//执行函数 mrDeng.smoke()
var deng = {
    prepareWife : "xiaowang",
    name : "laodeng",
    sex : "male",
    gf : "xiaoliu",
    wife : "",
    divorce : function() {
        delete this.wife;
        this.gf = this.prepareWife;
    },
    getMarried : function() {
        this.wife = this.gf;
    },
    changeGf : function(someone) {
        this.prepareWife = someone;
    }
}
//改变属性值
deng.changePrepareWife('xiaozhang');
构造函数的内部原理: (三段论)
    1.在函数体最前面隐式的加上 this = {};
    2.执行 this.xxx = xxx;
    3.隐式的返回 this;
function Student(name, age, sex) {
    	//var this = {
        //  name : "",
        //  age : "",
        //  sex : "",
    	//};
    	this.name = name;
    	this.age = age;
    	this.sex = sex;
    	this.grade = 2017;
    	//return this;
}
console.log(new Student('sxw', 24, male).name); //这样也能调用对象
包装类:
	new String();
	new Boolean();
	new Number();
1.数字123是原始值,原始值是不能有属性和方法的;
2.属性和方法只有对象有,是对象独有的特性;
3.对象包括自己,数组,function;
4.正常的数字有原始值类型和对象类型,原始值类型数字是没有属性和方法的,但是对象类型是有的;
5.正常的字符串有原始值类型和对象类型;
6.正常的布尔值有原始值类型和对象类型;
7.数字的对象能够参与运算,但是运算的结果就不是对象了,又变回数字了;
8.
var num = new Number(123);
var str = new String('abc');
var bool = new Boolean('true');
9.undefined 和 null是不能设置属性的;
//包装类
var num = 4; //原始值是坚决不可能有属性和方法的,但是为什么可以调用呢？因为经历了包装类
num.len = 3;
//new Number(4).len = 3;  然后delete 
//电脑会新建一个数字对象,让这个数字对象的len等于3,来弥补我们操作的不足,完成之后电脑又会自动去销毁;
//new Number(4).len 当我们下面要去访问的时候,电脑又会满足我们的要求,再去new一个新的number,然后把4放进去,再去访问len,因为一个对象是没有属性的,所以返回值为undefined;
console,log(num.len); //undefined
var str = "abcd";
str.length = 2;
//new String('abcd').length = 2; --> delete
console.log(str); //"abcd"
console.log(str.length); //4
var str = "abc";
str += 1;
var test = typeof(str); //test == "string"
if(test.length == 6) {
    test.sign = "typeof的返回值结果可能为string";
    //new String(test).sign = 'xxx';
}
//new String(test).sign
console.log(test.sign); //undefined
//闭包问题
function Person(name, age, sex) {
    var a = 0;
    this.name = name;
    this.age = age;
    this.sex = sex;
    function sss() {
        a ++;
        document.write(a);
    }
    this.say = sss; //当外面new一个对象时,会把内部函数sss返回到全局下,形成闭包,并且函数sss会保存Person的劳动成果
}
var oPerson = new Person();
oPerson.say(); //1
oPerson.say(); //2
var oPerson1 = new Person();
oPerson1.say(); //1
var x = 1,y = z = 0;
function add(n) {
    return n = n + 1;
}
y = add(x);
function add(n) { //这两个函数是同一个,函数声明提升结果是下面这个函数覆盖上面这个函数,
    return n = n + 3; //return回去的是这个
}
z = add(x);
//x=? y=? z=? 1 4 4
下面代码中console.log的结果是[1,2,3,4,5]的选项是: A,C
A.
    function foo(x) {
        console.log(arguments) //arguments 数组形式的实参列表
        return x
    }
    foo(1,2,3,4,5)
b.
    function foo(x) {
        console.log(arguments)
        return x;
    }(1,2,3,4,5) //不报错,但也不执行
c.
    (function foo(x) {
        console.log(arguments)
        return x
    })(1,2,3,4,5) //立即执行函数
d.
	...
要实现一行文本水平垂直都居中;
	line-height = height , text-align : center; 
要实现元素水平垂直都居中;
    position: absolute; 
    top: 50%; 
    left: 50%; 
    margin-left: 负的宽度的一半; 
    margin-top: 负的高度的一般;
以下表达式的结果是什么？
    parseInt(3, 8); //3
    parseInt(3, 2); //NaN
    parseInt(3, 0); //3 或者 NaN
以下哪些是javascript语言typeof可能返回的结果?
    a.string //可以
    b.array //不可以
    c.object //可以
    d.null //不可以,历史遗留性问题,属于object
function test(x, y, a) {
    a = 10;
    console.log(arguments[2]); //10 注意arguments和形参是一一对应的,两者不管谁变对方都会相应发生变化
}
test(1, 2, 3);
---------------------
function test(x, y, a) {
    arguments[2] = 10;
    console.log(a); //10
}
test(1, 2, 3);
原型
定义: 
原型是function对象的一个属性,原型是构造函数构造出来的对象的祖先;
通过该构造函数产生的对象,可以继承该原型的属性和方法;
原型也是对象;
1.利用原型特点和概念,可以提取共有属性;
(构造函数构造出来的对象不是有很多属性是一致的嘛,我们就可以把这些属性放到原型对象上,这样就避免了每一次去new一个对象都需要去执行一次相同属性的代码,放到原型上就直接继承了)
2.对象如何查看原型 -> 隐式属性 _proto_;
3.对象如何查看对象的构造函数 ---> constructor;
(在这个原型的内部,一开始系统给我们生成原型的时候,就自带了一个属性叫构造器constructor,目的就是让构造函数构造出来的对象想找对应的构造函数的时候能够找到。即就是有一天一个对象找不到是谁生了自己的时候,通过constructor属性,就可以找到构造他的对应的构造函数)
4.通过后代是不能够修改/删除原型上的属性的,通过构造函数构造的对象也是无法修改/删除原型上面的属性的;
5.prototype 是函数一定义就会有的,只不过我们没有给她定义的时候是一个空对象;
//Person.prototype ={}  原型
Person.prototype.name = "hehe";
function Person() {};
var person = new Person(); 
//这样下来,虽然new出来的对象本身没有东西,但是当我们访问person.name的时候还是会返回祖先的name的,即继承了祖先的name属性;
原型的第一个应用: 
当我们的构造函数构造出来的对象有一些属性是一致的时候,我们可以把这些属性定义到原型上面,简化执行操作;
Car.prototype = { //这样书写笔下面这样书写更好
    height : 1400,
    lang : 4900,
    carName : "BMW",
}
    //Car.prototype.height = 1400;
    //Car.prototype.lang = 4900;
    //Car.prototype.carName = "BMW";
function Car(color, owner) {
    this.owner = owner;
    this.color = color;
    // this.carName = "BMW";
    // this.height = 1400;
    // this.lang = 4900;
}
var car = new Car('red', 'sxw');
Person.prototype.name = 'abc'; //给Person原型链上新添了一个name属性
function Person() {
    //var this ={
    //      _proto_ : Person.prototype;
    //当我们要找对象上面的属性时,如果对象上面没有我们所要找的属性,就会通过_proto_指向的索引,到_proto_ 后面的值对应的身上去找有没有我们需要的属性。相当于连接的关系,把原型和自己通过_proto_连接到了一起。_proto_后面存的是当前对象的原型,_proto_就是一个指向,但是我们可以改变这个指向,间接的去改变对象的原型;
    //};
}
var person = new Person();
person.name
Person.prototype.name = 'sunny'; //原型链
function Person() {} //构造器
var person = new Person(); //创建对象
person.prototype.name = 'sxw' //在原有的基础上把值给修改了
//原型上的 name 值是 sxw
-------------------------------------------------------
Person.prototype.name = 'sunny';
function Person() {
    //var this = {_proto_ : Person.prototype}
}
var person = new Person();
Person.prototype = { //把原型给修改了,相当于换了个新对象
    name : 'sxw'
}
//原型上的name是sunny
-------------------------------------------------------
//var obj = {name : "a"};
//var obj1 = obj;
//obj = {name : "b"};
-----------------------------------------
Person.prototype = {name : "a"};
_proto_ = Person.prototype;
Person/prototype = {name : "b"};
-----------------------------------------
function Person() {
    //var this = {_proto_ : Person.prototype}
}
Person.prototype.name = 'sunny';
var person = new Person(); //这个相当于在new之后修改的原型
Person.prototype = {
    name : 'cherry';
}
原型链
原型链上属性的增删改查;
绝大多数对象的最终都会继承自 Object.prototype; 
*注意是绝大多数,因为我们可以使用 Object.create(原型) 来实现;
Object.create(原型); //括号里原型处只能填 Object / null;
一个对象的原型只能是对象 / Null;
Object prototype may only be an Object or null;
对象是通过 _proto_ 索引找到原型的;
Object.create(null); //这样构造出来的对象没有原型,没有.toString();方法,但是他却是是一个对象,但是这个对象就这么奇怪的没有原型;
Grand.prototype._proto_ = Object.prototype //原型链的终端
	Grand.prototype.lastName = "Deng";
	function Frand() {
	}
	var grand = new Grand();
	Father.prototype = grand;
	function Father() {
        this.name = 'xuming';
	}
	var father = new Father();
	son.prototype = father;
	function Son() {
        this.hobbit = "smoke";
	}
	var son = new Son();
	//原型链上的原型只能通过自身去删除/修改属性,想要通过子孙后代去修改是实现不了的;
	function Father() {
        this.name = 'xuming';
        this.fortune = {
            card1 : 'visa'
        };
        this.age = 100; 
        //当我们通过 son.age ++ 形式返回出来的时候, son.name 是101,原型上依旧是100,因为我们是先把原型的值取出来加等于1再赋给自身的;
	}
	var father = new Father();
	Son.prototype = father;
	function Son() {
        this.hobbit = "smoke";
	}
	var son = new Son();
	//虽然通过后代无法改变原型链上的属性,但是可以通过给引用值加东西去达到修改的目的;
	//son.fortune.name,这种是引用值自身的修改,这不算赋值的修改;
//a.sayName()
//sayName 里面的this指向是,谁调用了这个方法,this就指向谁
Person.prototype = {
    name : "a",
    sayName : function() {
        console.log(this.name);
    }
}
function Person() {
    this.name = "b";
}
var person = new Person(); //b
------------------------------------
Person.prototype = {
    height : 100
}
function Person() {
    this.eat = function() {
        this.height ++;
    }
}
var person = new Person(); //自身++, 原型不变
var obj = {}; 相当于new Object();是一个效果  //平时构造对象的时候最好用这个方式
//var obj1 = new Object();
//obj1._proto_ ---> Object.prototype (原型链终端)
---------------------------------------------
Person.prototype = {} ---> Object.prototype //原型链的终端
function Person() {
}
//var obj = Object.create(原型);
Person.prototype.name= "sunny";
function Person() {
}
var person = Object.create(Person.prototype); 
//这种形式和上面构造器其实质是一样的;
//原型是系统内部隐式的东西,我们自己加_proto_是没用的,系统给我们了,我们可以去修改,但是系统说没有这个东西,我们去人为添加,系统是不承认的;
//undefined 和 null 不能调用 toString 方法, undefined.toString();报错 / null.toString();报错
//undefined 没有包装类,是一个原始值,没有原型,也就没有toString方法;
//123.toString(); 数字能够调用toString方法,因为数字能够经过包装类,一层一层往上访问,包装类能够包装起来,就说明她是一个对象,对象就有原型链的终端; 
var num = 123;
//num.toString(); --> 相当于 new Number(num).toString();
Number.prototype.toString = function() {}
//Number.prototype._proto_ = Object.prototype
//Object.prototype.toString = function() {}
Person.prototype = {
    toString : function() { 
    //半路截断式,这种和她原型链终端名字一样,但实现不同功能的方法,叫做方法的重写。即我不想让你访问到终端上的属性,我要覆盖你的属性,系统自带有Object.prototype上面拥有toString方法,但是我不想用你的,我不光不用你的,我还要取一个名字和你一样的;
        return 'hehe';
    }
}
function Person() {
    
}
var person = new Person();
//其实不光我们会去重写原型上的属性和方法,系统自己也会去重写自己原型上的属性和方法:
//Object.prototype.toString
//Number.prototype.toString
//Array.prototype.toString
//Boolean.prototype.toString
//String.prototype.toString
所以我们
var num = 123;
num.toString(); 
//调用的是 Number 的 toString,并不是调用原型上面的 toString;
这是为啥呢?因为当我们跳过自身直接去访问原型链上面的时候:
Object.prototype.toString.call(123); 
//返回[object Number],并不能返回对应数字的字符串,所以系统内部给我们重新定义了一个;
------------------------------------------------------------------------
var obj = Object.create(null);
obj.toString = function() {
    return '我是sxw';
}
document.write(obj); //打印的是 我是sxw;
document.write(obj.toString()); //但是如果我们上面说过采用Object.create(原型);实现对象没有原型,那么就不能调用toString方法了,除非我们人为又去添加一个toString方法;
小bug
toFixed(); //保留两位有效数字
在控制台输入0.14*100 会出现bug
js精度不准;
js尽量避免小数操作 Math.floor(); 或者 Math.ceil();
js可正常计算的范围,小数点前16位,后16位;
call/apply
作用,改变this指向;
区别,后面传的参数形式不同,apply后面除了this外只能传一个实参,并且是数组形式的;
    call 需要把实参按照形参个数传进去;
    apply 需要传一个arguments,即 实参列表;
call和apply都是改变this指向,唯一的区别是传参列表不同;
------------------------------------------------
function test() { 
}
test() ---> //test执行,其实质是test.call执行 == test.call();
----------------------------------------------------------
function Person(name, age) {
	//this == obj,当我们不使用call的时候,这个this指向的是window,但当我们使用了call之后,这个this指向就会发生变化,改变指向变成call传进去的第一个参数对象,即指向这个,通过Person的环节来制造obj的属性,借用别人的环节来实现自己的构造;
    this.name = name;
    this.age = age
}
var person = new Person('deng', 100);
var obj = {
}
Person.call(obj, , ); 
//当把obj传进去的时候,这个call就会引导Person发生变化,她会让Person里面所有预设的this,全部都变成obj,即this = obj,然后在第二位开始传参数
Person.call(obj, 'deng', 30); 
//Person执行,.call执行,第一个参数会改变this指向,第二位以后的参数会当做正常的实参传到形参里面去
call的根本作用就是改变this指向,我借用你的方法来改变this指向,我通过call的方法,借用你的方法,来实现我的功能,利用别人的方法来实现自己的功能;
function Person(name, age, sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
}
function Student(name, age, sex, tel, grade) {
	//var this = {}
    Person.call(this, name, age, sex); 
    //Person.call一定会调用Person来执行的,后面的this,就是当我们new出来对象的时候,隐式所产生的this,将call后面第一个属性this去代替Person里面的属性中的this,三个this统一。即当我们需要使用别人的功能的时候,直接别人的函数名.call
    this.tel = tel;
    this.grade = grade;
}
var student = new Student('sunny', 123, 'male', 138, 2019);
//call只有一个功能,改变this指向,借用别人的函数实现自己的功能;
function Wheel(WheelSize, style) {
    this.style = style;
    this.WheelSize = WheelSize;
}
function Sit(c, sitColor) {
    this.c = c;
    this.sitColor = sitColor;
}
function Model(height, width, len) {
    this.height = height;
    this.width = width;
    this.len = len;
}
function Car(wheelSize, style, c, sitColor, height, width, len) {
    wheel.call(this, wheelSize, style);
    Sit.call(this, c, sitColor);
    Model.call(this, height, width, len);
}
var car = new Car(100, '花里胡哨的', '真皮', 'red', 1800, 1900, 4900);
```

```
基础知识:
1.函数的定义方式:
	a.函数声明; function name() {};
	b.函数表达式; var func = function() {};
*注意: 只有匿名函数表达式才简称函数表达式;
2.parseInt();
	把字符串中的有效"整数"内容取出来转换为Number类型,从左往右读,读到非整数即停止;
3.互相嵌套的函数,外面的函数不能访问里面函数的内容,里面的函数可以访问外面的函数的内容。
即越往里权限越大:
eg:
    function test() {
        var a = 123;
        function demo() {
            var b = 456;
            console.log(a); //123
        }
        demo();
        console.log(b); //报错
    };
    test();
4.请使用css和html写一个三角形; (使用js实现好看的效果)
    .sjx{
        //width: 100px;
        //height: 100px;
        width: 0px;
        height: 0px;
        //background-color: yellow;
        border-top: 50px solid red;
        border-right: 50px solid orange; (transparent)
        border-bottom: 50px solid green; (transparent)
        border-right: 50px solid blue; (transparent)
    }
    <div class="sjx"></div>
6.请写出window.foo的值;
(window.foo || (window.foo = 'bar')); //bar

8.写一个函数,实现斐波那契数列; (第三位数等于前两位数之和)
eg:1 1 2 3 5 8...
    function fb(n) {
        if(n == 1 || n == 2) {
            return 1;
        }
        return fb(n - 1) + fb(n - 2)  
    };
9.js: 单线程,解释性语言: 翻译一句执行一句;
预编译
基础知识:
1.imply global暗示全局变量: 即任何变量,如果变量未经声明就赋值,此变量为全局对象所有;
	eg: a = 123; ---> window.a = 123;
2.一切声明的全局变量,全是window的属性;
	eg: var a = 123; ---> window.a = 123;
3.window 就是全局的域;
    var a = 123;
    var b = 234;
    var c = 456; 
    ==== 相当于 ====
    window {
        a : 123,
        b : 234,
        c : 456;
    }
	console.log(a); === console.log(window.a);
4.但凡在全局定义的变量window里面都有对应的属性;
5.预编译发生在函数执行的前一刻;
6.形参名,变量名,函数名一样,我们需要解决一个优先级顺序的问题,即谁覆盖谁的问题,执行顺序是怎样影响变量,
影响函数,这就是预编译需要解决的问题;
eg:
    function fn(a) {
        console.log(a); //function a() {}
        var a = 123; //预编译提升声明变量,但是赋值还是需要看的,将a = 123代替AO对象里a属性的值
        console.log(a); //123
        function a() {} //预编译已经将其提升,所以不用再看
        console.log(a); //123
        var b = function() {} //var b不用看了,修改AO里的b,值为function() {}
        console.log(b); //function() {}
        function d() {}
        console.log(d); //function d() {}
    }
    fn(1);
    
运行三部曲:
    1.语法分析; (通篇扫描一遍,看看有没有语法错误,但不执行)
    2.预编译;
    3.解析执行; (解释一行执行一行)
function test(a,b) {
    console.log(a); //1
    c = 0;
    var c;
    a = 3;
    b = 2;
    console.log(b); //2
    function b() {}
    function d() {}
    console.log(b); //2
    console.log(d); //function d() {}
}
test(1);
---------------------------
预编译四部曲:
1.创建AO对象(执行期上下文);
    AO{

    }
2.找形参和变量声明;
(AO找的是局部范围里的,GO找的是全局范围里的),将形参和变量名作为AO属性名,值为undefined;
    AO{
        a : undefined,
        b : undefined,
    }
3.将实参值和形参相统一;
    AO{
        a : 1,
        b : undefined,
    }
4.在函数体里面找函数声明,值赋予函数体;
    AO{
        a : function a() {},
        b : undefined,
        d : function d() {},
    }
    
function test(a,b) {
    console.log(a); //function a() {}
    console.log(b); //undefined
    var b = 234;
    console.log(b); //234
    a = 123;
    console.log(a); //123
    function a() {}
    var a;
    var b = function() {}
    console.log(a); //123
    console.log(b); //function() {}
}
test(1);
1.函数声明整体提升: 不管是在函数声明之前调用函数还是在函数声明之后调用函数,其本质都是在函数声明之后
调用函数,他始终会把函数声明提升到逻辑的最前面;
    console.log(a); //function a() {}
    var a = 123;
    function a() {};
2.变量 声明提升: 只是将定义变量部分提升,赋值部分不提升;
    console.log(a); //undefined
    var a = 123;
3.GO全局状态下,预解析没有第三步,并且第一步是生成一个GO对象; GO === window
    var a = 123;
    function a() {};
    console.log(a); //123
4.
function test() {
    var a = b = 123;
    console.log(window.a); //undefined GO里面没有a定义
    console.log(window.b); //123
    console.log(a); //123
    console.log(b); //123 AO里面没有的话往上找GO
}
test();
----------
GO{
    b : undefined,123
}
AO{
    a : undefined,123
}
5.
console.log(test); //function test() {} 和下面打印出来的fun指的不一样
function test(test) {
    console.log(test); //function test() {}
    var test = 234;
    console.log(test); //234
    function test() {}
}
test(1);
----------
GO{
    test : function test() {} 
}
AO{
    test ; undefined,1,function test() {},234
}
6.
var global = 100;
function fn() {
    console.log(global); //100 先去AO里面找,AO里面没有,再去GO上找
}
fn();
---------------
GO{
    global : undefined,100
    fn : function fn() {},
}
AO{
    
}
7.
global = 100;
function fn() {
    console.log(global); //undefined
    global = 200; //可以改变AO里对应属性的值
    console.log(global); //200
    var global = 300;
}
fn();
console.log(global); //100
var global;
--------------
GO{
    global : undefined,100
    fn : function fn() {}
}
AO{
    global : undefined,200,300
}
8.
function test() {
    console.log(b); //undefined
    if(a) { //a = undefined,所以b = 100不执行
        var b = 100; //AO 提升
    }
    console.log(b); //undefined
    c = 234;
    console.log(c); //234
}
var a;
test();
console.log(a); //undefined
a = 10;
console.log(a); //10
console.log(c); //234
-------------------------
GO{
    a : undefined,10
    c : 234,
    test : function test() {}
}
AO{
	b : undefined
}
9.
function bar() {
    return foo; //function foo() {} 在完成预编译第四步后进来走程序直接return,必然返回function
    foo = 10;
    function foo() {}
    var foo = 11;
}
console.log(bar());
10.
console.log(bar());
function bar() {
	console.log(foo); //function foo() {}
    foo = 10;
    console.log(foo); //10
    function foo() {}
    var foo = 11;
    return foo; //11 
}
11.
a = 100;
function demo(e) {
    function e() {}
    arguments[0] = 2; //实参列表,传参与传参的形参位相映射即 e = 2
    console.log(e); //2
    if(a) { //a = undefined,所以if里面的语句不执行
        var b = 123;
        function c() {
        
        }
    }
    var c;
    a = 10;
    var a;
    console.log(b); //undefined
    f = 123;
    console.log(c); //理想状态下是function,因为规定里刚刚新添if语句里面不能定义函数
    console,log(a); //10
}
var a;
demo(1);
console.log(a); //100
console.log(f); //123
-------------
GO{
    a : undefined,100
    demo : function demo() {}
    f : 123
}
AO{
    e : undefined,1,function e() {},2
    b : undefined
    c : undefined,function c() {}
    a : undefined,10
}
14.
只有一种情况使用没有定义的变量是不报错的,就是typeof(a) ---> 返回的是字符串类型的undefined;
typeof(null) ---> "object" 
(null本来是原始值,但在typeof这里被认为是给对象占位的,所以认为null是个对象)
15.
if(typeof(a) && -true + (+undefined) + "") { //有数学符号的一般都转化为数字,转不了的为NaN
	//结果为: “undefined” && "NaN"
	document.write('基础扎实'); //能够打印出来
}
16.
if(11 + "11" * 2 == 33) { //不管乘法两边有什么东西,都是要转换成数字的,"11" * 2 = 22
    document.write('基础扎实');
}
17.
!!" " + !!"" - !!false || document.write('你觉得能打印,你就是猪');
非非空格字符串 --> 变成布尔值,变成ture + false - false = 1 || ...
```

```
继承发展史
1.传统形式 ---> 原型链
	过多的继承了没用的属性;
2.借用构造函数
	不能继承借用构造函数的原型;
	每次构造函数都要多走一个函数;
3.*共享原型
	不能随便改动自己的原型;
4.圣杯模式
------------------------------
共享原型demo:
    Father.prototype.lastName = "Deng";
    function Father() {}
    function Son() {}
    Son.prototype = Father.prototype //不通过原型链的形式就继承Father的原型;
--------------------------------------------------------------------------
//问题:
    Father.prototype.lastName = "Deng";
    function Father() {};
    function Son() {};
    function inherit(Target, Origin) { //封装函数实现继承
        Target.prototype = Origin.prototype;
    }
    //如果我们想给 son 原型上单独设置一个 sex 属性,通过下面代码实现之后,不光通过Son函数构造出来的
    对象的原型有了sex属性,Father构造函数构造出来的对象上的原型也修改了。因为两个函数指向同一个房间,
    所以这个方法不太好;
    Son.prototype.sex = "male"; //导致Father构造出来的对象原型也变了;
    inherit(Son, Father);
    var son = new Son();
--------------------------------------------------------------------
//想要实现虽然 Son 继承 Father 的原型,但是 Son 自己还是能单独给原型上添加新属性,同时对Father不
//产生影响;  即: ---> 圣杯模式
//                                Father.prototype
//
//                                              function F() {} //通过添加一个中间构造函数
//                                              F.prototype = Father.prototype
//
//                                              Son.prototype = new F();
//                   Father                               Son
---------------------------------------------------------------------------------
//圣杯模式
function inherit(Target, Origin) {
    function F() {};
    F.prototype = Origin.prototype;
    Target.prototype = new F();
    Target.prototype.construct = Target; //解决下面son原型上construct属性指向紊乱的问题
    Target.prototype.uber = Origin.prototype; 
    //超超类,即我们是通过中间商F函数构造器来实现继承的,如果有一天我想知道创建出来的对象究竟最顶端的
    原型是谁,通过这一步可以实现;
}
Father.prototype.lastName = "Deng";
function Father() {};
function Son() {};
inherit(Son, Father);
var son = new Son();
var father = new Father();
//这样有一个问题就是son的construct紊乱了;
//son._proto_ --> new F()._proto_ --> Father.prototype //son的construct指向的是Father
------------------------------------------------------------------------------------
//优化圣杯模式:
var inherit = (function() {
    var F = function() {}; 
    //形成闭包,F函数变成下面函数的私有化变量,因为这个F函数本身就是拿来过渡一下的,本身并没有什么实际
    意义上的作用,所以我们把她放到闭包里面,去当做一块私有化变量来使用;
    return function(Targegt, Origin) {
        F.prototype = Origin.prototype;
        Target.prototype = new F();
        Target.prototype.construct = Target;
        Target.prototype.uber = Origin.prototype;
    }
}());
//私有化变量时应用;
function Deng(name, wife) {
    var prepareWife = "xiaoliu"; 
    //私有化变量,函数Deng自己是无法调用识别出这个变量的,只有通过函数Deng里面拥有的属性,并且这个
    属性里的方法与Deng形成闭包,继承Deng函数的Ao,通过这种方法才能度取出这个私有化变量;
    this.name = name;
    this.wife = wife;
    this.divorce = function() { //闭包产生了
        this.wife = prepareWife;
    }
    this.changePrepareWife = function(target) {
        preppareWife = target;
    }
    this.saypreparewife = function() {
        console.log(prepareWife);
    }
}
var deng = new Deng('deng', 'xiaoliu');

命名空间
管理变量,防止污染全局,适用于模块化开发;
过去解决命名空间问题的方法:
var org = {
    department1 : {
        sxw : {
            name : "abc",
            age : 23;
        },
        kobe : {
            name : "qwe",
            age : 24,
        }
    },
    department2 : {
        AI : {
            name : "Allen Iverson"
        }
    }
}
var sxw = org.department1.sxw;
sxw.name进行调用;
现在解决这个问题的方法是webpack;
----------------------------------------
//闭包 + 立即执行函数,实现变量私有化,不会污染全局变量;
所以我们就可以把特定的函数功能写到闭包里面去,留出来一个接口,方便去启动她;
var init = (function() {
    var name = 'abc';
    function callName() {
        console.log(name);
    }
    return function() { 
    //留出来的接口就是return的这个函数,因为我们要实现一个功能的时候都是函数调用函数实现的功能,
    所以我们return一个函数作为接口,传给init函数,当init被调用的时候,就会启动函数体里面的函数,所以
    功能实现了,但是不会污染全局变量; //init初始化,入口
        callName();
    }
}())
init();

//小技巧,模仿jq实现一个方法的连续调用:
var deng = {
    smoke : function() {
        consle.log('Smoking');
        return this; //这里很关键
    },
    drink : function() {
        console.log('drinking');
        return this;
    },
    eat : function() {
        console.log('eating');
        return this;
    }
}
deng.smoke().drink().eat().smoke();

访问对象属性的另一种方法:
var obj = {
    name : "abc"
}
obj.name  === obj['name'] 以后尽量写成这样
----------------------------------
//利用属性拼接实现一个功能:
var deng = {
    wife1 : {name : "xiaoA"},
    wife2 : {name : "xiaoB"},
    wife3 : {name : "xiaoC"},
    sayWife : function(num) {
        return this['wife' + num];
    } //这样就实现了deng.sayWife(num)的时候会切换;
}

对象的枚举:
for in
*1.hasOwnProperty; //过滤性方法,看看这个属性是自身的还是原型上的
2.in 
	'age' in obj; --> true; 
	in只会去判断当前对象上面能不能访问到该属性,不管是自身上的还是原型链上的
*3.instanceof;  A instanceof B;
	看A对象的原型链上有没有B的原型,即[] 可以看到 array,还可以看到Object原型链终端)
--------------------------------
var obj = {
    name : 'sxw',
    sex : "male",
    age : 24
}
for(var prop in obj) {
    //console.log(prop + "" + typeof(prop));
    //console.log(obj.prop ---> obj['prop']); 
    //obj.prop相当于访问的是obj对象里面属性名为prop的,电脑会给我们自动转换;
    console.log(obj[prop]); 
    //以后记住,对象里枚举只能使用[],养成习惯,以后所有写对象属性的时候后都写成[]的形式;
}
----------------------------
var obj1 = {
    a : 123,
    b : 234,
    c : 455,
}
for(var key in obj1) {
    obj1.key ++; //实现obj里面的数都加1 
}
-------------------------------------
//只想要自己身上的属性,不想要原型上的属性:
var obj = {
    name : '123',
    age : 23,
    _proto_ : {
		lastName : "deng"
    }
}
for(var prop in obj) {
	if(obj.hasOwnProperty(prop)) {
        console.log(obj[prop]);
	} 
	//obj.hasOwnProperty 返回的是一个布尔值,即判断当前属性是不是自身的还是原型上的,
	如果是原型上的返回false,如果是自身的,则返回true,执行if里面的代码,注意var in只会
	遍历一层原型链,即原型链前的原型链他是会放弃遍历的
}
----------------------------------------
typeof([]); --> object
typeof({}); --> object
区分数组与对象的三种方法:
1.
[].constructor --> array;
var obj = function() {}	;
obj.constructor --> Object;
2.
[] instanceof Array --> true;
var obj = {};
obj instanceof Array ---> false;
3.
Object.prototype.toString.call([]); --> [object Array];
Object.prototype.toString.call({}); --> [object object];
---------------------------
null == undefined
----------------------
var obj = {};
var obj1 = obj;
obj1 == obj;
obj1 === obj

this指向
1.函数预编译过程 this;  --->  window;
2.全局作用域里 this;  --->  window;
3.call/apply 可以改变函数运行时 this 指向;
4.obj.func(); func()里面的 this 指向 obj;
----------------------------------------
经典this指向:
var name = "222";
var a = {
    name : "111",
    say : function() {
        console.log(this.name);
    }
}
var fun = a.say;
fun(); //fun在全局范围下执行,也没人去调用他,所以打印222
a.say(); //111

var b = {
    name : "333",
    say : function(fun) {
    	//this ---> b
        fun(); 
        //fun是一个参数,参数执行,参数只是在函数体里面执行,并没有人调用,空执行,谁也没有调用fun,
        所以走的预编译环节,this指向window,所以window.name,打印 222
    }
}
b.say(a.say);
b.say = a.say;
b.say();
-----------
arguments
arguments 对象 数组 类数组
	a.arguments.callee;
	b.func.caller;
----------------------
function test() {
    console.log(arguments.callee == test); //打印的就是他自己
}
test();
-----------------------
用递归 + 立即执行函数实现 n 的阶乘 + arguments.callee(指向自身的引用)
var num = (function (n) {
    if(n == 1) {
        return 1;
    }
    return n * arguments.callee(n - 1); //这里找自身只能用arguments.callee,因为没有函数名
}(100))
--------------------
var foo = '123';
function print() {
    var foo = '456';
    this.foo = '789'; //this指的是window
    console.log(foo); // 456 在自己函数体里面打印foo
}
print();
----------------------------
var foo = 123;
function print() {
    this.foo = 234;
    console.log(foo); //234 在函数体里面打印,但是函数体里面没有foo,所以去全局里面找;
}
print();
--------------------------
var foo = 123;
function print() {
//var this = Object.create(print.prototype)   new一个对象相当于隐式生成这个
    this.foo = 234; //只是改变函数体里面的foo,对全局没有产生影响
    console.log(foo); //因为函数体实质上是没有foo的,所以还是打印全局的foo
}
 new print();
 ---------------------------
 运行test() 和new test()的结果分别是什么？
 var a = 5;
 function test() {
 	//var this = { //new的时候隐式出现的对象里面没有a,所以打印undefined
 	//	_proto_ : test.prototype;
 	//}
     a = 0;
     alert(a); //0   0 (前面是test,后面是new)
     alert(this.a); //5   undefined
     var a;
     alert(a); //0   0
 }
 AO{
     a : undefined,0,
     this : window,
 }
 test();
 new test();
 AO{
     //new的时候;
     a : 0,
     this : {},
 }
 -------------------------
 function print() {
     console.log(foo); //undefined
     var foo = 2;
     console.log(foo); //2
     console.log(hello); //报错,hello is not defined.
 }
 print();
 ---------------------
 function print() {
     var test;
     test();
     function test() {
         console.log(1); //1
     }
 }
 print(); 
 -----------------------
 function print() {
     var x = 1;
     if(x == "1")console.log("One!");
     if(x === "1")console.log("Two!");
 }
 print();
 ------------------------------------
 var bar = {a : "002"};
 function print() {
     bar.a = 'a';
     Object.prototype.b = 'b';
     return function inner() {
         console.log(bar.a); //a
         console.log(bar.b); //b
     }
 }
 print()();
克隆
深度克隆: 克隆完成的对象,不论是引用值还是原始值,都是各自独立的;
var obj = {
    name : "abc",
    age : 123,
    card : ['visa', 'master'],
    wife : {
        name : "bcd",
        son : {
            name : aaa
        }
    }
}
var obj1 = {
    name : obj.name, //原始值直接拷贝就行;
    age : 123,
    card : [obj.card[0], obj.card[1]],
    wife : {
        name : "bcd", //是原始值,直接拿过来
        son : {
            
        }
    }
}
--------------------------------------------------------------------------------
属性判断: (判断是原始值还是引用值,引用值需要特殊拷贝,原始值直接拷贝;引用值的话考虑是数组还是对象)
    var arr = ['a','b','c'];
    for(var prop in arr) { //数组也是特殊的对象,也可以使用for in
        console.log(arr[prop]);
    }
-----------------------
深度克隆思路步骤:
//遍历对象 for(var prop in obj)
//1.判断是不是原始值; typeof(),结果如果是object则是引用值,如果不是基本上都是原始值,先不考略null;
//2.引用值的话,判断是数组还是对象; //3种方法 建议使用toString();
//3.建立相应的数组或对象;
//递归
------------------------------------
深度拷贝:
function deepClone(origin, target) {
    var target = target || {}; //target有就用target,没有就使用||后面的;
    	toStr = Object.prototype.toString,
    	arrStr = "[object Array]"; //拿过来,等一下方便比对
    for(var prop in origin) {
        if(origin.hasOwnProperty(prop)) { //判断去除原型上的属性
        	if(origin[prop] !== "null" && typeof(origin[prop]) == 'object') { //判断是不是原始值
                //判断引用值是数组的引用值还是对象的引用值
                if(toStr.call(origin[prop]) == arrStr) { //是数组
                    target.[prop] = [];
                }else {
                    //对象
                    target[prop] = {};
                }
                deepClone(origin[prop], target[prop]); //递归,再次循环上面的过程
        	}else {
                target[prop] = origin[prop]; //搞定原始值
        	}
            
        }
    }
    return target;
}

使用三目运算符简化上面的深度克隆代码:
深度拷贝:
function deepClone(origin, target) {
    var target = target || {}; //target有就用target,没有就使用||后面的;
    	toStr = Object.prototype.toString,
    	arrStr = "[object Array]"; //拿过来,等一下方便比对
    for(var prop in origin) {
        if(origin.hasOwnProperty(prop)) { //判断去除原型上的属性
        	if(origin[prop] !== "null" && typeof(origin[prop]) == 'object') { //判断是不是原始值
                //判断引用值是数组的引用值还是对象的引用值
                //if(toStr.call(origin[prop]) == arrStr) { //是数组
                //    target.[prop] = [];
                //}else {
                //    //对象
                //    target[prop] = {};
                //}
                target[prop] = toStr.call(origin[prop]) == arrStr ? [] : {};
                deepClone(origin[prop], target[prop]); //递归,再次循环上面的过程
        	}else {
                target[prop] = origin[prop]; //搞定原始值
        	}
            
        }
    }
    return target;
}

数组
数组的两种形式:
	a) var arr = [];
	b) var arr = new Array();
Array.prototype   <---  数组所有的方法都来自
--------------------------------------------
两种形式之间的区别 (传参为1个参数的时候触发):
var arr = new Array(10); //长度为10的稀松数组,默认10为数组的长度 (, , , , , , , , , )
var arr1 = [10]; //就是10
-----------------------------
DOM 通过js操作html
BOM 通过js操作浏览器 (浏览器不兼容问题大多出现在这里)

数组常用的方法:
(改变原数组类型)
	push 给数组最后一位添加新数据,一次可以添加任意位数据
	pop 把数组最后一位剪切掉,不能传参数
	shift 和pop方向相反,把数组最前面的数剪切掉
	unshift 和push方向相反,在数组最前面加东西
	*sort 给数组排序,在原数组的基础上进行排序
	(按ASIC码为单位进行,不是我们想要的效果,但是sort给我们留了一个接口,方便实现我们的需求)
	reverse 逆转原数组的顺序
	splice 切片
(不改变原数组)
	concat 连接两个数组	arr.concat(arr1);把后面数组排到前面数组上,成为一个独立的新数组
	join 传的参数必须是字符串形式的
	split 与join可逆,按照我们所传的参数进行拆分数组
	toString 
	slice 切片(从该位开始截取,截取到该位)两个参数,包括从该位开始截取,不包括截取到该位;一个参数的话
	是从第几位开始截取,一直到最后;不传参数,全截,后面课程中把类数组转换为数组的时候可以使用
--------------------------------------------------------------------------
模拟系统push方法:
var arr = [1,2,3];
Array.prototype.push = function() {
    for(var i = 0;i < arguments.length; i ++) {
        this[this.length] = arguments[i];
    }
    return this.length;
}
---------------------------------
var arr = [1,1,1,2,2,2,3,3,3];
arr.splice(从第几位开始,截取多少的长度,在切口处添加新的数据),算是一种剪切
arr.splice(1,2); //从第一位开始,往后截取两位
-------------------------------------------
var arr = [1,2,3,5];
arr.splice(3,0,4); //[1,2,3,4,5]
-------------------------------------------
当我们输入第一个数是负数的时候,系统给我们做的兼容:
splice = function(pos) {
    pos += pos > 0 ? 0 : this.length; 
    //如果我们输入第一个数是负数的时候,会执行这个负数加上数组长度再赋给自身
}
-------------------------
要求数组降序排序
arr.sort().reverse();
----------------------------
var arr = [1 ,3 ,5 ,4 ,10];
//系统给我们的要求,我们按照这个要求去写程序:
//1.必须写俩形参
//2.看返回值 1) 当返回值为负数时,那么前面的数放在前面;
//          2) 为正数,那么后面的数在前;
//          3) 为0,不动;
arr.sort(function(a,b) {
    //if(a - b > 0) {
    //    return a - b
    //}else {
    //    return a - b
    //}
    return a - b; //升序
    return b - a; //降序
});
-------------------------------
//给一个有序的数组,乱序
var arr = [1,2,3,4,5];
arr.sort(function() {
   	return Math.random() - 0.5; 
});
---------------------------------
给对象按照年龄进行排序:
var cheng = {
    name : "cheng",
    age : 18,
    sex : 'male',
    face : "handsome"
}
var deng = {
    name : "deng",
    age : 40,
    sex : undefined,
    face : amazing
}
var zhang = {
    name : "zhang",
    age : 20,
    sex : "male",
}
var arr = [cheng, deng, zhang];
arr.sort(function(a, b) {
    //if(a.age > b.age) {
    //    return 1;
    //}else {
    //    return - 1;
    //}
    return a.age - b.age;
})
-----------------------------------------------------
按字符串长度排序
var arr = ['sca','aswdwdw','a','uwgdbwhqugd uiqw'];
arr.sort(function(a,b) {
    return a.length - b.length;
})
------------------------------
按照字节长度来排序:
function retBytes(str) {
    var num = str.length;
    for(var i = 0;i < str.length;i ++) {
        if(str.charCodeAt(i) > 255) {
            num ++;
        }
    }
    return num;
}
var arr = ['a小‘,'b小','不能说的秘密'];
arr.sort(function(a,b) {
    return retBytes(a) - retBytes(b);
})
---------------------------------------------------
arr.join("-"); //将数组进行连接,按照我们传的参数进行连接
"1-2-3-4-5"
--------------------------------------------------------------------------------------
字符串的连接是栈内存的链接,符合先进后出,所以我们尽量不使用栈内存的方式进行拼接字符串,用散列结构
进行拼接;
var str = "alibaba";
var str1 = 'baidu';
var str2 = 'tencent';
var strFinal = "";
//散列
var arr = [str,str1,str2];
console.log(arr.join("")); //不传参数是按照逗号进行连接的
--------------------------------------------------------
类数组
1.可以利用属性名模拟数组的特性;
2.可以动态的增长length属性;
3.如果强行让类数组调用 push 方法,则会根据 length 属性值的位置进行属性的扩充;
4.类数组,长的像数组,也可以当做数组使用,但就不是数组;
----------------------------------------------------
arguments就是一个类数组
----------------------
//类数组满足的条件: 属性要为索引(数字)属性,必须有length属性,最好加上push方法;
var obj = {
    "o" : 'a',
    "1" : 'b',
    "2" : 'c',
    "length" : 3,
    "push" : Array.prototype.push,
    "splice" : Array.prototype.splice //一旦给对象加上spliice之后,这个对象长的就像数组了
}
---------------------------------
//push原理
Array.prototype.push = function(target) {
    obj[obj.length] = target;
    obj.length ++; //动态增长length属性
}
--------------------------
根据数组push的内部原理做下面题目:
var obj = {
    "2" : "a",
    "3" : "b",
    "length" : 2,
    "push" : Array.prototype.push
}
obj.push('c');
obj.push('d');
obj --> 
var obj = { //参考上面Array.prototype.push原理得出结果
    "2" : "c",
    "3" : "d",
    length : 4
}
---------------------------------------------------------
封装type
typeof([]) -- array
typeof({}) -- object
typeof(function) -- object
typeof(new Number()) -- number Object
typeof(123) -- number

function type(target) {
    //1.分两类 原始值(number string boolean直接用typeof判断,但是还有一个null,我们先判断) 引用值
    //2.区分引用值
    var template = {
        "[object Array]" : "array",
        "[object Object]" : "object",
        "[object Number]" : "number - object",
        "[object Boolean]" : "boolean - object",
        "[object String]" : "string - object"
    }
    if(target === null) {
        return "null";
    }else if(typeof(target) == "object") {
        //数组
        //对象
        //包装类 new Number(),通过Object.prototype.toString进行判断
        var str = Object.prototype.toString.call(target); 
        return template[str]; //解决引用值
    }else {
        return typeof(target);
    }
    
}
------------------------------------------------
数组去重 (要求在原型链上编程)
Array.prototype.unique = function() {
		// ???
}
var arr = [1, 1, 0, 0, 'a', 'a', 'b']; //原始
arr.unique() ---> [1,0.'a','b']; //目标
-------------------------------------------------
a) hash方式去重
借用对象的一个特性: 即对象的同一个属性名不可能出现两次来实现去重效果;
将数组中的属性值当做对象的属性名,经过一系列筛选操作之后返回对象的属性名;
Array.prototype.unique = function() {
    var temp = {},
        arr = [], //返回的去重后的数组
    	len = this.length; //减少代码计算次数
    for(var i = 0;i < len;i ++) {
  //a.数组中的属性值拿出来当做对象的属性名并与对象进行比对,如果对象上该属性名已经存在属性值,则忽略;
  //b.如果在对象上找不到该属性名对应的属性值,那么这个属性名即数组中对应的属性值就是我们想要的筛选结果;
  //c.我们随便给筛选出的我们想要的属性名赋予一个属性值进行标记,然后push出该属性名到新数组;
  //d.循环上面操作;
    	//if(temp[this[i]]) {
    	//	啥也不干
    	//}else {
    	//	取到 undefined 的时候,才是我们的操作
    	//}
    	
    	//简化代码
        if(!temp[this[i]]) { 
			//!undefined --> true,执行下面代码块
            temp[this[i]] = "abc";
            arr.push(this[i]);
        }
    }
    return arr;
}

1.值基本分为两种: 原始值 引用值(就是对象: 包括数组,函数,对象);
2.原始值之所以不是引用值是因为: 1.存储方法,他是存在栈内存里的;2.他是不可能有属性和方法的;
3.原始值确实是没有属性的,但我们想要通过原始值访问属性的话,电脑会隐式进行包装类操作,
即将new String('...').length的结果返回;我们写的是str.length(),但电脑执行的是
new String('...').length();电脑的这个隐式包装的过程就叫包装类;
4.对象才有属性和方法,并且可以灵活的调用和赋值;
-----------------------------------------
var demo = {
    lastName : "deng"
}
var obj = Object.create(demo); //创建对象,并且创建的这个对象的原型就是括号里面填的demo
obj = {
    _proto_ : demo;
}
----------------------------------------
var num = 123;
一旦经历了var的操作,所得出的属性,叫window属性,这种属性叫做不可配置的属性,不可配置的属性delete不掉;
------------------------------------
var name - 'window';
var obj = {
    name : "obj",
    say : function() {
        console.log(this.name);
    }
}
obj.say.call(window); //call打破规则,call里面传的是谁,this指的就是谁
--------------------------------
undefined 与 null 不能和数进行比较;
--------------------------------
(function(x) {
    delete x;
    return x; // 1
})(1); //相当于var x = 1;delete不了
-------------------------------
typeof(arguments); 类数组 --> Object
-------------------------------
var h = function a() {
    return 3;
}
console.log(typeof a()); //报错
---------------------------------------
选择你熟悉的一种方式实现JavaScript对象的继承！  (申明模式)
---------------------------------------------
输入1,返回星期一
function retDate(date) {
    var arr = ['一','二','三']；
    var ret = arr[date - 1];
    if(ret === undefined) {
        return 'error';
    }else {
        return ret;
    }
}
//在 try 里面发生错误,不会执行错误后的 try 里面的代码;
try{ 
	//有错误不抛出错误,不终止代码的运行,即后续try外面的代码还是会执行,如果我们不能确定一堆代码有
	没有错误,就把代码放到try里面;
    console.log('a');
    console.log(b); //报错
    console.log('c'); //忽略代码
}catch(e) { //catch负责捕捉错误,如果try里面的代码不出错,catch里面的代码是不会被执行的 
	//error error.message error.name ---> error 系统会把错误对象传到e里面去
	console.log(e.name + ":" + e.message);
}
console.log('d');
---------------------------------------
Error.name 六种值对应的信息:
	1.EvalError: eval()的使用与定义不一致;
	2.RangeError: 数值越界;
	*3.ReferenceError: 非法或不能识别的引用数值 (变量未经声明就使用);
	*4.SyntaxError: 发生语法解析错误 (中文进去了);
	5.TypeError: 操作数类型错误;
	6.URIError: URI处理函数使用不当;
es5严格模式:
	a.不再兼容es3的一些不规则语法,使用全新的es5规范;
	b.两种用法:
		全局严格模式;
		局部函数内严格模式(推荐)
	c.就是一行字符串,不会对不兼容严格模式的浏览器产生影响;
	d.不支持with,arguments.callee,func.caller 变量赋值前必须声明,局部this必须被赋值;
	e.(Person.call(null/undefined)赋值什么就是什么),拒绝重复属性和参数;
----------------------------------------------------------------------
在es5.0严格模式,es3.0和es5.0产生冲突的部分就是用es5.0,否则使用es3.0;
--------------------------------------------------------
"use strict"; //es5.0严格模式的启动,写在逻辑的最顶端,全局严格模式
function test() {
    console.log(arguments.callee); //es3.0部分方法就不能使用了,eg:arguments.callee
}
test();
------------------------
function test() {
    "use strict"; //局部函数内严格模式
    console.log(arguments.callee);
}
-------------------------------------------------------------------------
with可以改变作用域链,如果在with后面放对象,就可以将对象作为要执行的代码体的作用域链的最顶端
var obj = {
    name : "obj"
}
var name = 'window';
function test() {
    var name = 'scope';
    with(obj) {
        console.log(name); //obj
    }
}
test();
--------------------------------
with的应用
var org = {
    dp1: {
        jc : {
            name : 'abc',
            age : 123
        },
        deng : {
            name : "sxw",
            age : 344
        }
    },
    dp2: {
        
    }
}
with(org.dp1.jc) {
    console.log(name);
}
```

```
function add(a,b){
  var result = a+b;
  return "加法计算结果："+result;  
}
 
function sub(a,b){
  var result = a-b;
  return "减法计算结果："+result;  
}
 
// 使用apply方法，sub调用add的方法
var applyResult = add.apply(sub,[4,2]);　　
console.log(applyResult);  //输出6  
 
// 使用call方法，add调用sub方法
var callResult = sub.call(add,4,2);
console.log(callResult);  //输出2
```

```
6月26日
贪吃蛇demo:
	1.小蛇整体运动事件;
	2.键盘按键事件;
	3.检测碰撞事件;
	4.画网格;
	5.排他思想;
	6.三点需求的完善:
		a)小蛇运动不能脱离container;
		b)小蛇自己撞自己显示游戏结束;
		c)随机生成的食物不能生成在蛇身上;
```
