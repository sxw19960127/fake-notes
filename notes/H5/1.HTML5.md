---
title: HTML5
date: 2019-08-09 17:33:04
tags: HTML5
categories: Web前端开发
---

```
历史:
    ...XHTML1.0反应良好 (在html中引入xml,严格要求写法,一定程度上解决了浏览器兼容性问题)
    ...XHTML2.0过于严格 (且不支持旧的页面,不按规范来写,页面展示不出来,导致浏览器厂商不干了)
    ...WHATWG建立 (以拓展和改进html为目的)
    ...W3C与WHATWG合作 (2006年)
    HTML5 W3C规范 (2008年提出html5草案)
```

```
理念:
    1.避免不必要的复杂;
        Doctype:指示web浏览器关于页面使用哪个HTML版本进行编写的指令。
            html4.01: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML4.01...>
            html5简化为: <!DOCTYPE html>
        还有link,script,meta等标签。
    2.支持已有的写法;
    3.解决实际问题;
    4.优雅降级;
        很多标签里的属性当浏览器不支持某个新写法时,浏览器会降级到一个默认的支持属性;
    5.用户优先;
        用户 > 开发者(程序员) > 浏览器厂商 > 标准制定者
```

```
Doctype (标准模式/怪异模式)
验证:
	console.log(document.compatMode);
        返回BackCompat --> 表示怪异模式(按照各个浏览器来解析)
        返回CSS1Compat --> 表示标准模式(按照规范来解析)
区别:
    1.标准盒模型和IE6混杂模式盒模型;
    2.table字体在标准模式下继承body,怪异模式下不继承body;
    3.怪异模式IE6以下版本中可以给span等行级元素设置宽高;
    4.怪异模式下即使父级没有高度,也可以设置百分比高度;
    5.怪异模式IE6以下margin:0 auto不能左右居中;
    6.怪异模式IE6以下图片的padding失效;
    7.只有在IE6之前的浏览器才会触发IE6混杂模式;
    8.IE6混杂模式盒模型是微软超前的意识提出的,所以只有IE浏览器才会有;
    9.在怪异模式下盒模型的总宽度和高度是包含内边距padding和边框border在内的,所以盒子宽度即为width;
```

```
新特性:
    1.新语义元素;
    2.forms2表单元素HTML网页表单的改进,其中为<input>标记引入了新属性;
    3.音视频;
    4.画布;
    5.拖放;
    6.文件读取;
    7.回调函数管理api;
    8.地理位置;
    9.执行脚本多线程worker;
    10.本地存储;
    11.websocket;
    12.HistoryAPI;
    13.跨文档通信postmessage;
```

```
HTML5结构元素
<前5个使用比较多>
    1.header 整个页面的头部,某块区域的标题,页眉;
    2.footer 文档或者某一块的底部,页脚;
    3.main 主要内容区域;
    4.nav 导航链接部分;
    5.section 页面中一个内容区域;
    
    6.article 它代表一个独立的,完整的相关内容块;
    7.aside 表示一个页面的一部分,和这个页面的其他内容关联性不强,或者是没有关联,单独存在;
    8.figure 规定独立的流内容(图像,图表,照片,代码...);
```

```
HTML5功能元素
1.video 视频;
2.audio 音频;
3.source 资源;
4.canvas 画布;
5.progress 进程;
6.figcaption 标签定义(了解即可);
```

```
controls 显示出相应视频音频的控件
poster是为视频第一帧设置海报,只有video有
<video height="600px" controls src="./video/1.mp4" poster="./1.png"></video>
<audio src="./video/1.mp3" controls></audio>
<audio controls>
   <source src="./video/1.mp3"> //先去服务器里看一下有没有mp3格式
   <source src="./video/1.ogg"> //没有的话再去申请ogg格式,按顺序加载
</audio>
<script> //js动态创建Audio
    var myAudio = new Audio('./video/1.mp3'); //和img标签一样
    myAudio.controls = 'controls'; //这里直接等于true,也行
    document.body.appendChild(myAudio); //插入到dom当中,添加子元素
</script>
<canvas width=600 height=600></canvas>
<progress id="pro" max=100 min=0 value=30></progress>
浏览器支持情况:
    canPlayType()方法,audio.canPlayType() --> 返回probably或者maybe,返回空为不支持
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            span{
                display: none;
            }
        </style>
    </head>
    <body>
        <progress id="pro" max=100 min=0 value=0></progress>
        <span id="ok">完成</span>
        <script>
            var timer = setInterval(function() { //设置计时器
//平时练习的时候可以不写document.getElementById("pro")来获取dom节点,通过对应的id值.属性      
                if(pro.value === 100) { 
                    clearInterval(timer);
                    ok.style.display = "block";
                }else {
                    pro.value += 10;
                    console.log("检查计时器有没有清除");
                }
            },1000);
        </script>
    </body>
</html>
```

```
HTML5表单元素
<input type="text"> 文本框
<input type="radio"> 小圆点
<input type="checkbox"> 复选框
<input type="password"> 密码
<input type="submit"> 提交
<input type="button"> 按钮
<input type="file"> 上传文件
input新属性:
    1.multiple 可上传多个文件;
    2.placeholder 提示用户当前文本框是干啥作用的;
    3.pattern 验证input类型输入框中内容是否与正则匹配;
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <input type="text">
        <form action="">
//应用场景,radio单选框,性别选择,name必须相同才能起到单选的目的,value是提交时候后台获取的值
            <input type="radio" name="sex" value="male">男生 
            <input type="radio" name="sex" value="female">女生
            <input type="submit">
        </form>
        <form action="">
			应用场景,checkbox复选,提交到后台的时候是name=value的形式
            <input type="checkbox" name="eat" value="apple">苹果
            <input type="checkbox" name="eat" value="pear">梨
            <input type="submit">
        </form>
        <form action="">
        	自动把我们输入的值作为value值
            <input type="password" name="word">
            <input type="submit">
        </form>
        <input type="button" value="ok"> //小按钮
        <form action="">
            <input type="file" multiple> //multiple可以同时选择多个文件
            <input type="submit">
        </form>
    </body>
</html>
```

```
input type新增
    <input type="tel">
    <input type="range"> //进度条
    <input type="number">
    <input type="search">
    <input type="email">
    <input type="datatime-local"> //表示本地日期和时间,支持情况不是很好
    <input type="color"> //供我们选择颜色的
    <input type="date"> //以下四个使用不多
    <input type="month">
    <input type="week">
    <input type="time">
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            input{
                display: block; //独占一行
            }
        </style>
    </head>
    <body>
        <form action="">
            <input type="tel"> //当前文本框是一个输入电话号码的文本框,移动端比较明显
只能输入数字和下划线,当超过规定数值范围提交的时候会提示,在移动端的时候会自动弹出一个数字键盘
            <input type="number" max="100" min="0">
            <input type="email" value="123@qq.com">
            <input id="range" type="range" max="100" min="0" step="10" value="0">
            <input type="submit">
        </form>
        <script>
            range.onclick = function() {
                // console.log(this);
                console.log(this.value); //谁调用了这个函数,这个函数里的this就指向谁
            };
        </script>
    </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <form action="">
        	//pattern属性可以代替下面js里的正则表达式
            <input id="test" type="text" pattern="^\d{6}$" name="num">
            <input type="submit">
        </form>
        
        <script>
            //用正则表达式写输入框内只能书写6位数字
//^以...开头 ,$以...结束(锁定了只能输入6个数字) ,// ,\d表示数字 ,{6}只能书写6位 ,g只有6位
            var reg = /^\d{6}$/g;
            test.onblur = function() { //失去焦点的时候value值是几位
                if(reg.test(this.value)) { //匹配对应test函数,匹配的是input框中的value值
                    this.style.borderColor = "green";
                }else {
                    this.style.borderColor = "red";
                }
            };
        </script>
    </body>
</html>
```

```
Audio/Video元素基本属性
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <audio id="myAudio" controls src="./video/1.mp3"></audio>
        <script>
            var obj = {
                aa: function() {
                    console.log(3);
                }
            }
            if(obj.aa) {
                console.log("有！")
            }
            //检验我们的浏览器是否支持audio标签以及支持什么格式的音频
            var myAudio = document.getElementById('myAudio');
            if(myAudio.canPlayType) {
                if(myAudio.canPlayType("audio/mpeg") != "") {
                    document.write("您的浏览器支持mp3编码;");
                    // --> probably
                }
                if(myAudio.canPlayType('audio/ogg; codecs="vorbis"') != "") {
                    document.write('您的浏览器支持ogg编码;');
                    // --> probably;
                }
                if(myAudio.canPlayType('audio/mp4; codecs="mp4a.40.5"') != "") {
                    document.write('您的浏览器支持aac编码');
                    // --> probably
                }
            }else {
                document.write("您的浏览器不支持要检测的音频文件");
            }
        </script>
    </body>
</html>
```

```
Audio/Video 属性:
	1.muted 静音;
	2.autoplay 自动播放,注意在静音muted的条件下而且只有video好用;
	3.controls 调出控件;
	4.loop 循环播放,视频音频都行;
	5.preload(none/metadata/auto) 是否预加载;
         none:不进行预加载;
         metadata:部分进行预加载,提供基本的没啥用的信息,宽高,但是里面的内容是不加载出来的;
         auto:全部预加载;
		 preload="metadata";
	6.currentSrc 获取资源链接(注意要资源加载完成后才能获取到);
        var myAudio = document.getElementById("myAudio");
        myAudio.oncanplay = function() { 
        //为啥要绑定一个canplay事件,因为我们获取资源链接是需要等视频链接加载完的,而canplay事件是不确定按照当前播放速率能否将视频播放完,既然都能够播放视频了,肯定已经加载完地址了
          console.log(myAudio.currentSrc);  
        };
	7.duration 媒体持续时间(总时长,注意要资源加载完成后才能获取到)在canplay事件函数里面去检测;
	8.currentTime 返回或设置资源当前时间;
        <audio id="myAudio" src="./song.mp3" controls>
        <button id="current">currentTime</button>
        <script>
            var myAudio = document.getElementById('myAudio');
            current.onclick = function() {
                console.log(muAudio.currentTime);
            };
        </script>
	9.volume 音量[0-1],可读可写;
        <audio id="myAudio" src="./1.mp3" controls></audio>
        <button id="lessVolume">-</button>
        <button id="addVolume">+</button> //为啥不写成addvolume,大写是为了下面直接获取dom节点
        <button id="quick">快进</button>
        <button id="slow">慢放</button>
        <button id="p">play/pause</button>
        <button id="btn">btn</button>
		<script>
            //var myAudio = document.getElementById("myAudio");这样获取dom节点比较规范
            lessVolume.onclick = function() {
                var volume = parseInt((myAudio.volume - 0.1)* 10) / 10;
                if(volume >= 0 && volume <= 1) {
                    myAudio.volume = volume;
                } 
                console.log(myAudio.volume);
            };
            addVolume.onclick = function() { //bug待解决:为啥音量只能加到0.7就上不去了
                var volume = parseInt((myAudio.volume + 0.1) * 10) /10;
                if(volume >= 0 && volume <= 1) {
                    myAudio.volume = volume;
                }
                console.log(myAudio.volume);
            };
            quick.onclick = function() {
                myAudio.playbackRate += 0.1;  
            };
            slow.onclick = function() {
                myAudio.playbackRate -= 0.1;  
            };
            p.onclick = function() {
                if(myAudio.paused) {
                    myAudio.play();
                }else {
                    myAudio.pause();
                }
            };
            //判断两种状态进行标识
            var flag = true;
            p.onclick = function() {
                flag = !flag;
                if(flag) {
                    console.log(1);
                }else {
                    console.log(0);
                }
            };
            btn.onclick = function() {
                myAudio.src = "./2.mp3"; //实现切歌的效果
                myAudio.load(); //重新加载资源,在有自动播放的时候当做切歌比较舒服
            };
            //事件的触发
            myAudio.onplay = function() {
                console.log("我播放啦~");
            };
            myAudio.onpause = function() {
                console.log("我暂停啦~");
            };
            myAudio.onended = function() {
                cosole.log("我结束啦~");
            };
		</script>
```

```
Audio/Video 方法:
    play() 播放
    pause() 停止
    load() 重置媒体元素并重新载入媒体,可中止正在进行的任务或事件 
```

```
Audio/Video 事件:
    play 媒体开始播放时触发
    pause 媒体暂停时触发
    ended 资源播放结束
    canplay 浏览器能够开始播放媒体数据,但是不确定已当前的速率能否顺利的播放完媒体
```

```
Audio/Video 属性(了解即可):
	1.playbackRate 读取或设置媒体资源播放的当前速率(大于1快放,大于0小于1慢放,无倒放);
	2.paused/ended/seeking 查询媒体播放状态,返回true/false;
	3.paused 是否暂停,返回状态true/false;
	4.ended 判断音频是否结束了;
	5.seeking 正在请求某一播放位置的媒体数据,了解即可;
	6.player/buffered/seekable 均返回一个TimeRanges对象;
		timeRanges对象的length属性为部分时间段;
		end(i)返回已播放时间段的结束时间;
		start(i)返回已播放时间段的开始时间;
	7.played 标明媒体资源在浏览器中已播放的时间范围;
		在两个暂停中间进行的播放时间长度,返回一个数组,当然也可以获取播放开始的时间和播放结束的时间
	8.buffered 确定浏览器已经缓存媒体文件;
	9.seekable 表明可以对当前媒体资源进行请求;
```

```
Canvas画布
1."Canvas、Node.js、Express、MongoDB、Mongoose、Angular、React、Redux、Vue、Vuex、ECMAScript2016、typescript、webpack、gulp、Angular2、HybridApp...”都是加分项;
2.根本的能力是业务的书写水平:
    对代码的感觉要非常的高,对代码的疯狂,每天晚上都要学;
    读文档的能力(包括英语文档的能力),快速查询知识的能力,百度查询知识的能力;
    学会思考、比较、对比,能提出自己独到的观点;
3.学会制作:
	Canvas游戏-HTML5水果忍者、结合HTML5+CSS3制作的酷炫网页、手机端的婚礼请柬 相册;
4.小游戏:
    打砖块
    是男人就下100层
    别踩黑块
    围住神经猫
    会飞的小鸟
    推箱子
    捕鱼达人
    小兔子吃月饼
```

```
Canvas简介:
1.Canvas画布,是HTML5中非常重要的一个更新亮点,可以替代Flash的;
2.制作动画、游戏,渲染效率非常高,浏览器不需要安装任何的插件就可以渲染动画;而Flash是需要安装Flash Player插件才行;
3.Canvas是一个在面试中极度加分的项目,完整的去检验大家内功水平,全是面向对象;
4.Canvas是一个标签,有一个默认的宽度,（不需要了解）。注意:如果我们要设置画布的宽高的时候,必须在HTML标签上设置,而不能在CSS上设置;
5.Canvas在网页上呈现居然是一个会动的图片,我们可以右键图片另存为;
6.我们必须使用JavaScript来控制Canvas渲染各种东西;
7.ctx对象非常重要,所有的绘制都是ctx方法;
8.canvas兼容到IE9;
9.笔触和填充:Canvas中能够产生颜色的是两种东西:一个叫笔触(老百姓叫做描边),另一个叫做填充。
绘制的线可以用fill填充,并且可以用strock来描边。需要注意的是,形状如果不封闭就fill了,此时形状会自动封闭,但是与封闭的区别在于封闭的那条线就没有了;
ctx.strokeRect 矩形描边
ctx.fillRect 矩形填充
10.属性是用等号赋值,方法是用圆括号调用;
11.弧和圆形 ---> arc(x, y, radius, startAngle, endAngle, anticlockwise);
画一个以(x,y)为圆心，以radius为半径的圆弧(圆)，从startAngle开始到endAngle结束，按照anticlockwise给定的方向(默认为顺时针)来生成。
一定要注意,在canvas中角度是弧度制的。复习一下弧度制，就是在一个圆形披萨饼中，切一片披萨，让弧度边长等于圆的半径。此时无论圆形多大,切下来的角度是固定的,都是57.29度,称为1弧度,记做1rad。360° = 2* PI rad 
绘制一个圆形:ctx.arc(200,200,100,0,2*Math.PI,false);
```

```
API小结:
快速矩形描边		 ctx.strokeRect(x,y,w,h);
开始绘制路径		 ctx.beginPath();
封闭路径		     ctx.closePath();
将画笔移动到某个点   ctx.moveTo(x,y);
移动画笔画线,但是是虚拟的线		ctx.lineTo();
画线				 ctx.stroke();
填充				 ctx.fill();
改变线的颜色		 ctx.strokeStyle = "red";
改变填充颜色		 ctx.fillStyle = "red";
快速矩形填色		 ctx.fillRect(x,y,w,h);
清除一个矩形区域     ctx.clearRect(x,y,w,h);
得到上下文	         mycanvas.getContext("2d");
mycanvas.getContext("2d") ------> Context是上下文的意思。Canvas起初是空白的,为了展示,首先脚本需要找到渲染上下文,然后在它的上面绘制。<canvas>元素有一个getContext()的方法,这个方法是用来获得渲染上下文和它的绘画功能。getContext()只有一个参数,上下文的格式;
设置图片的宽度和高度:ctx.drawImage(图片对象,dx画布上的左上角的x,dy画布上的左上角的y,100图片的宽,70图片的高);可以使用4个数字参数;
比如:我们现在想在canvas上面呈递切片中的位置:
将这个切片放置在画布的100,100 呈递的宽度、高度是切片的2倍;
ctx.drawImage(image,299,94,93,76, 100,100,93*2,76*2); //前四个数是切片在原图上的位置的左上顶点和宽高,后四个数是canvas上的位置的左上顶点和宽高
```

```
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
	//注意，给canvas设置宽和高的时候不能在上面style样式里面设置，应该在canvas标签属性头部设置
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        //使用DOM方法得到画布
        var mycanvas = document.getElementById("mycanvas");
        //使用画布的上下文,所有的命令是由他发出的，而不是画布发出的。ctx即为context的缩写
        var ctx = mycanvas.getContext("2d");
        //画各种东西,用ctx打点调用方法,而不是myCanvas;
        //画一个矩形,从点(100,100),画一个宽300,高40的矩形;
        ctx.fillRect(100,100,300,40);
        //所有的步骤都是ctx在打点,和canvas无关,所有API的绘制都是ctx的事情,而不是canvas对象;
        ctx.fillStyle = "blue";
        ctx.beginPath();
        //画一个圆,圆心(300,300),半径100,从0画到2π,顺时针逆时针随便
        ctx.arc(300,300,100,0,Math.PI*2,true);
        ctx.fill();
        ctx.closePath();
    </script>
</body>
</html>
```

```
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //笔触,只有描边没有里面的填充色
        // ctx.strokeStyle = "red";
        // ctx.strockRect(x, y, width, height);
        // ctx.strokeRect(100,100,300,40);

        //线
        ctx.beginPath(); //开始一个路径 (必须要有的)
        ctx.moveTo(100, 100); //第一个点,移到点(100,100);(必须要有的)
        ctx.lineTo(300, 300); //画一条线到点(300, 300),此时是一条抽象的线,没有画到画布上;
        ctx.lineTo(300, 200); //可以不断进行画线;可以多次使用lineTo;
        ctx.closePath(); //自动去封闭路径;
        ctx.lineWidth = "10"; //设置描边线的粗细;
        ctx.lineJoin = "round"; //改变线的端点形成的凹凸程度;
        ctx.strokeStyle = "red"; //改变描边的颜色;
        ctx.stroke(); //画线！必须调用stroke命令,把上面这条抽象的线给画下来;
        ctx.fillStyle = "pink"; //改变填充的颜色;
        ctx.fill(); //对这个形状进行填充;
    </script>
</body>
</html>
```

```
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //弧也是笔触
        ctx.beginPath();
		//圆心(200,200) 半径(100) 起始的弧度(0) 终止的弧度(1) true表示逆时针。
        ctx.arc(200,200,100,0,1,true);
        ctx.arc(100,100,50,0,2 * Math.PI,false);
        ctx.stroke();
        ctx.fill();
    </script>
</body>
```

```
画一个小人头:
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");
        
        ctx.beginPath();
        ctx.arc(200,200,100,0,Math.PI * 2,true); 
        ctx.stroke();
        ctx.fillStyle = "pink";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(150,180,20,0,Math.PI * 2,true); 
        ctx.stroke();
        ctx.fillStyle = "red";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(250,180,20,0,Math.PI * 2,true); 
        ctx.stroke();
        ctx.fillStyle = "red";
        ctx.fill();

        ctx.beginPath();
        ctx.arc(200,170,90,0.5,2.6,false);
        ctx.stroke();
    </script>
</body>
```

```
贝塞尔曲线(稍微了解一下):
一次贝塞尔曲线
    <head>
        <style>
            canvas{border: 1px solid red;}
        </style>
    </head>
    <body>
        <canvas width="600" height="400" id="mycanvas"></canvas>
        <script>
            var mycanvas = document.getElementById("mycanvas");
            var ctx = mycanvas.getContext("2d");
            
            ctx.beginPath(); 
            ctx.moveTo(100, 100);
            // ctx.quadraticCurveTo(cp1x, cp1y, x, y);
            // 如果控制点(cp1x,cp1y)出现在100-300之间，则是一条直线
            ctx.quadraticCurveTo(200, 200, 300, 300);
            ctx.stroke(); 
        </script>
    </body>
    
二次贝塞尔曲线
    <body>
        <canvas width="600" height="400" id="mycanvas"></canvas>
        <script>
            var mycanvas = document.getElementById("mycanvas");
            var ctx = mycanvas.getContext("2d");
            
            ctx.beginPath(); 
            ctx.moveTo(100, 100);
            // ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
            //ctx.bezierCurveTo(150, 150, 250, 250, 300, 300); 如果两个控制点与起始点和终止点相对应的话，就又是一条直线
            ctx.bezierCurveTo(150, 50, 250, 450, 300, 300); //左边一头往上提，右边一头往下压
            ctx.stroke(); 
        </script>
    </body>
</html>
```

```
运动:
1.让元素在canvas上运动起来,需要使用定时器setInterval();
2.Canvas使用了一个特殊的模式。上屏的元素,立刻被像素化。也就是说,上屏幕的元素,你将得不到这个“对象”;
3.一个圆形画到ctx上面,此时就是一堆像素点,不是一个整体的对象了,你没有任何变量能够得到这个圆形,改变这个圆形的x、y;
4.所以Canvas有一个机制,叫做上屏幕的元素是不能改变形状、位置的。你要想产生运动,必须重新画一个。所以Canvas的画图原理就是:清屏 --> 重绘 --> 清屏 --> 重绘 -->......;
5.和DOM中的盒子运动完全不一样,DOM中我们试图更改同一个DOM元素的属性;
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var x = 100;
        setInterval (function() {
            x++; //通过改变步长变换运动快慢 x+=10;
            ctx.clearRect(0, 0, 600, 400); //清屏,从左上角(0,0)到画布整个宽和高
            //绘制一个新的圆形
            ctx.beginPath();
            ctx.arc(x, 100, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "orange";
            ctx.fill();
        },20) //每20毫秒去执行里面的语句
        //每20毫秒清屏,重绘,其实不是一个圆,只是我们的视觉残留觉得他在运动
    </script>
</body>
改变运动速度的两种方法:
    1.改变步长;
    2.改变时间;
```

```
DOM元素的移动:
<head>
    <style>
        div{
            width: 200px;
            height: 200px;
            background-color: orange;
            position: relative; /*动起来的话要有一个定位*/
        }
    </style>
</head>
<body>
    <div></div>
    <script>
        var div = document.getElementsByTagName("div")[0]; 
        var left = 0;
        setInterval(function() {
            left++;
            div.style.left = left + "px";
        },20)
    </script>
</body>
DOM的思维在Canvas中一定要抛弃;
```

```
两个圆在动:
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var x = 100;
        setInterval (function() {
            x++;
            ctx.clearRect(0, 0, 600, 400);
            ctx.beginPath();
            ctx.arc(x, 100, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "orange";
            ctx.fill();

            ctx.beginPath();
            ctx.arc(x, 300, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "blue";
            ctx.fill();
        },20)
    </script>
</body>
```

```
两个圆:一个从100起步,另一个从200起步
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var x1 = 100;
        var x2 = 200;
        setInterval (function() {
            ctx.clearRect(0, 0, 600, 400);
            
            x1++;
            ctx.beginPath();
            ctx.arc(x1, 100, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "orange";
            ctx.fill();

            x2++;
            ctx.beginPath();
            ctx.arc(x2, 300, 50, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = "blue";
            ctx.fill();
        },20)
    </script>
</body>
```

```
面向对象:
不管页面上有几个元素在运动,一定只有一个定时器。定时器负责每帧清屏一次,然后重绘所有元素。但是关键是所有元素的信息、状态你难以维护,所以需要面向对象。
    <head>
        <style>
            canvas{border: 1px solid red;}
        </style>
    </head>
    <body>
        <canvas width="600" height="400" id="mycanvas"></canvas>
        <script>
            var mycanvas = document.getElementById("mycanvas");
            var ctx = mycanvas.getContext("2d");
            
            //构造函数,圆类
            function Ball(x, y, r, speed) { //要有一个构造函数,要有一个类Ball
                this.x = x; //坐标x
                this.y = y; //坐标y
                this.r = r; //半径
                this.speed = speed; //速度
            }
            //渲染的方法
            Ball.prototype.render = function() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
                ctx.closePath();
                ctx.fill();
            }
            //更新的方法
            Ball.prototype.update = function() {
                this.x += this.speed;
            }
            //实例化一个小球
            var b = new Ball(100, 100, 50, 2);
            //唯一的一个定时器
            setInterval (function() {
                ctx.clearRect(0, 0, 600, 400); //清屏
                b.update(); //让小球更新
                b.render(); //渲染
            },20);
        </script>
    </body>
我们用对象把数据进行牢牢地封装！
所以,我们不要再用全局变量来维护某一个小球的x,y,r,speed等信息,而是应该用对象来封装她。
```

```
两个小球的运动:
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="400" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //构造函数,圆类
        function Ball(x, y, r, speed) { //要有一个构造函数，要有一个类Ball
            this.x = x; //坐标x
            this.y = y; //坐标y
            this.r = r; //半径
            this.speed = speed; //速度
        }
        //渲染的方法
        Ball.prototype.render = function() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fill();
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.speed;
        }
        //实例化一个小球
        var b1 = new Ball(100, 100, 50, 2);
        var b2 = new Ball(80, 200, 20, 8);
        //唯一的一个定时器
        setInterval(function() {
            ctx.clearRect(0, 0, 600, 400); //清屏
            b1.update(); //让小球更新
            b1.render(); //渲染

            b2.update();
            b2.render();
        },20);
    </script>
</body>
```

```
让所有演员(就是上画布的元素),都要进入数组,在定时器中,每一帧更新所有演员,渲染所有演员。
```

```
<head>
    <style>
        canvas{border: 1px solid red;}
    </style>
</head>
<body>
    <canvas width="600" height="600" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //构造函数,圆类
        function Ball(x, y, r, speed, color) { //要有一个构造函数,要有一个类Ball
            this.x = x; //坐标x
            this.y = y; //坐标y
            this.r = r; //半径
            this.speed = speed; //速度
            this.color = color; //颜色
            actorsArr.push(this);//将自己推入数组
        }
        //渲染的方法
        Ball.prototype.render = function() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.speed;
        }
        //演员数组
        var actorsArr = [];
        //实例化一些小球,他们都可以自动动画
        new Ball(100, 100, 30, 2, "red");
        new Ball(100, 200, 40, 3, "pink");
        new Ball(100, 300, 50, 4, "skyblue");
        new Ball(100, 400, 60, 5, "yellow");
        //帧编号,可以显示在屏幕左上角
        var fno = 0;
        //唯一的一个定时器
        setInterval(function() {
            ctx.clearRect(0, 0, mycanvas.width, mycanvas.height); //清屏
        //打印帧编号
        fno ++;
        ctx.fillStyle = "black"; //设置帧编号的颜色
        ctx.fillText("帧编号:"+ fno, 20, 20);
            //更新、渲染所有演员
            //用for循环来遍历
            for(var i = 0;i < actorsArr.length; i++) {
                actorsArr[i].update();
                actorsArr[i].render();
            }
        },20);
    </script>
</body>
```

```
项目:鼠标移动炫彩小球
<head>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        body{
            background: black;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <canvas id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        //设置画布满屏
        mycanvas.width = document.documentElement.clientWidth;
        mycanvas.height = document.documentElement.clientHeight;
        //小球类
        function Ball(x,y) {
            this.x = x; //圆心横坐标x
            this.y = y; //圆心纵坐标y
            this.r = 30; //半径给定死
            this.color = "rgba(" + parseInt(Math.random() * 256) + "," + parseInt(Math.random() * 256) + "," + parseInt(Math.random() * 256) + ",0.8)";
            this.dx = parseInt(Math.random() * 8) - 4; //x的变化值
            this.dy = parseInt(Math.random() * 8) - 4; //y的变化值
            ballsArr.push(this); //让自己进入数组
        }
        //更新的方法
        Ball.prototype.update = function() {
            this.x += this.dx;
            this.y += this.dy;
            this.r --; //半径减小，当自己半径没有的时候要从数组中清除自己了
            if(this.r < 0) {
                this.godie(); //执行godie函数
            }
        }
        //渲染的方法
        Ball.prototype.render = function() {
        	ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        //自杀函数
        Ball.prototype.godie = function() {
            //遍历数组,因为不知道数组中第几项
            for(var i = 0; i < ballsArr.length; i++) {
                if(ballsArr[i] === this) { //如果数组中有值等于自己
                    ballsArr.splice(i, 1); //让数组删除自己，第i项，删1项
                }
            }
        }
        //把类构建好以后要学会静态的去测试一下
        //var b = new Ball(100,100);
        //b.render();
        
        //小球数组
        var ballsArr = [];
        //监听
        mycanvas.onmousemove = function(event) {
            new Ball(event.clientX , event.clientY)
        }
        //定时器
        setInterval(function() {
            //清屏
            ctx.clearRect(0, 0, mycanvas.width, mycanvas.height);
            //渲染、更新所有小球
            for(var i = 0; i < ballsArr.length; i++) {
                ballsArr[i].update();
                //因为update可能会删除这个小球(半径小于0)，所以要验证一下这个小球是否存在
                ballsArr[i] && ballsArr[i].render(); 
            };
        }, 20);
    </script>
</body>
```

```
使用图片:
canvas中不可能所有的形状都自己画,一定是美工给我们素材,我们使用;
canvas中使用图片,使用drawImage函数,但是有一个事必须注意,必须等img完全加载之后才能呈递图片;
    <body>
        <canvas width="400" height="600" id="mycanvas"></canvas>
        <script>
            var mycanvas = document.getElementById("mycanvas");
            var ctx = mycanvas.getContext("2d");

            //创建一个img对象的孤儿节点
            var image = new Image();
            image.src = "img/1.jpg";
            //一定要等到这个图片loading之后,然后渲染她
            image.onload = function() {
                ctx.drawImage(image, 0, 0, 350, 550);//img这张图放到(0,0)位置上去宽350高550
            }
        </script>
    </body>
```

```
使用精灵制作元素行走:
<head>
    <style>
        canvas{border: 1px solid #333;}
    </style>
</head>
<body>
    <canvas width="800" height="1200" id="mycanvas"></canvas>
    <script>
        var mycanvas = document.getElementById("mycanvas");
        var ctx = mycanvas.getContext("2d");

        var image = new Image();
        image.src = "img/1.png";

        var step = 0;
        var x = 100;
        image.onload = function() {
            setInterval(function() {
                //清屏
                ctx.clearRect(0, 0, 800, 1200);
                step++;
                if(step > 3){
                    step = 0;
                }
                x+=12;
                ctx.drawImage(image, 71* step, 111*0, 71, 111, x, 100, 71, 111);
            },100)
        }
    </script>
</body>
```

```
在一个元素上通过调用API,进行绘画,使得浏览器重排重绘渲染的过程减少,因为只需要对一个元素进行渲染。
应用场景:
	1.游戏场景;
	2.大量数据图表;
	3.动画; demo网站(codepen.io),集合了很多小demo的网站。
发展简史及支持情况:
    1.Canvas标记由Apple在Safari1.3Web浏览器中引入;
    2.目前主流浏览器都支持,ie9之前的不支持;
    3.html5;
使用:
html
	<canvas width="100" height="100"></canvas> //宽高的单位不是像素,没有单位,是一个相对的单位
js
    var canvas = document.getElementsByTagName("canvas")[0];
    var ctx = canvas.getContext("2d"); 注意,Canvas获取绘画上下文的api是getContext("2d");
绘制图形:
1.直线
    moveTo(x,y); 画笔挪到起始点(x,y)
    lineTo(x,y); 画笔划线到另一点(x,y)
2.样式
    stroke(); 描边画
    lineWidth = 20; 设置线宽
    strokeStyle = 'red'; 线的颜色
    closePath(); 闭合路径
    fill(); 填充画
    fillStyle = 'red';填充颜色
设置图形 线样式:
    1.lineWidth: 线条宽度;
    2.lineCap: 线两头样式butt/square/round;
    3.lineJoin: 两线拐角处miter/round/bevel;
    4.miterLimit: 绘制交点的方式;
```

```
绘制图形:
    //三角形a
    ctx.moveTo(100,100);
    ctx.lineTo(200,100);
    ctx.lineTo(200,200);
    ctx.closePath();
    ctx.strokeStyle = 'red';
    ctx.stroke();
    //三角形b
    ctx.moveTo(100,300);
    ctx.lineTo(200,300);
    ctx.lineTo(200,400);
    ctx.closePath();
    ctx.strokeStyle = 'green';
    ctx.stroke();
问:浏览器展示的两个三角形分别是什么颜色的？
解:因为是在同一个路径上的,所以下面的效果会把上面的效果给覆盖掉,即同一个属性写了两遍,解决办法是再重新开启一个新的路径ctx.beginPath()。fill和stroke方法都是作用在当前的所有子路径,若想开辟新的路径,在绘制新路径之前需要使用beginPath();
```

```
矩形:
	rect(x,y,w,h); 坐标点 宽度 高度
	strokeRect(x,y,w,h); 描边画矩形,自己是一个单独的路径,不对其他路径进行影响,等于重新开辟一个路径
	fillRect(x,y,w,h); 填充画矩形,自己是一个单独的路径,不对其他路径进行影响,相当于重新开辟一个路径
圆形:
	arc(x,y,sAngle,eAngle,false,c); 中心点 半径 起始弧度 终止弧度(0,Math.PI*2 --> 圆) 
														   默认是false按照顺时针画的
曲线:
	两条切线之间的弧或者曲线
	arcTo(x1,y1,x2,y2,r);
二次方,三次方曲线方程:
    quadraticCurveTo(cpx,cpy,x,y);
    bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y);
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{ //以这里为实际宽高
                border: 1px solid #000;
                width: 200px;
                height: 200px;
            }
        </style>
    </head>
    <body>
    	//如果style里面没有设置宽高,则默认为400px;
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById('myCanvas');
            console.log(myCanvas.offsetWidth); //获取画布的宽是style里的属性
            var ctx = myCanvas.getContext('2d'); //canvas的API,画笔

            ctx.lineWidth = 20; //设置线宽,没有单位
            ctx.strokeStyle = 'red'; //设置描边的颜色
            ctx.fillStyle = 'green'; //设置填充的颜色
            ctx.moveTo(100, 100); //挪动画笔到(100,100)
            ctx.lineTo(200, 100); //画到(200,100)
            ctx.lineTo(200, 200); 
            ctx.lineTo(100,100); //其实这里不一定要重新回到原点也能实现填充
            ctx.closePath(); //路径闭合可以解决上面一行代码产生的缺了一个角的问题,即上面这行代码不写,换成这一行,就不存在缺口的问题了;
            ctx.rect(100, 100, 100, 100); //坐标x,坐标y,宽,高
            ctx.fill(); //填充渲染出来
            ctx.stroke(); //描边渲染出来

            ctx.beginPath();
            ctx.moveTo(100, 200);
            ctx.lineTo(200, 200);
            ctx.lineWidth = 20;
            ctx.lineCap = 'round'; //butt默认,square/round
            ctx.stroke();
        </script>
    </body>
</html>
```

```
渐变:
	线性渐变:起点和终点,这里只是规定一个方向,从某一点到另一点方向的渐变
		createLinearGradient(x1,y1,x2,y2);
	径向渐变:从某一个圆到另一个圆的渐变
		createRadialGradient(x1,y1,r1,x2,y2,r2);
绘制图案:
    createPattern(img,'repeat|repeat-x|repeat-y|no-repeat'); //把图片放到canvas中
    img:图片,画布,视频元素;
    注意:等资源加载完;
```

```
操作图形:
1.translate(dx,dy); 
重新映射画布上的(0,0)位置,平移了坐标系,改变了中心点,操作的是整个画布,在平移之后下面所画的图形也是带有平移之后效果的;		ctx.translate(100,100);
2.scale(sx,sy);
缩放当前绘图
ctx.scale(0.5, 2); 水平方向缩小为原来的0.5倍,垂直方向拉伸为原来的2倍
3.rotate(Math.PI);
旋转当前的绘图
ctx.rotate(Math.PI*0.25);
4.save();
保存当前图像的一份拷贝;
5.restore();
栈中弹出存储的图形状态并恢复
6.setTransform(a,b,c,d,e,f);
参数:a水平缩放,b水平倾斜,c垂直倾斜,d垂直缩放,e水平移动,f垂直移动
变换矩阵,先重置再变换,会清空原来的坐标系再重新开始绘制
7.transform(a,b,c,d,e,f);
在之前的基础上变换,不会清空坐标系,继续绘制(6和7是一样的)
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <img id="img" src="./video/1.jpg" alt="">
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var img = document.getElementById('img');
            img.onload = function() {
                var bg = ctx.createPattern(img, 'repeat');
                ctx.fillStyle = bg;
                ctx.fillRect(0, 0, 400, 400);
            };
            //var bg = ctx.createLinearGradient(0,100,400,100); //这里换成var bg = ctx.createRadialGradient(200, 200, 50, 200, 200, 100);同心圆,一个半径是50,一个半径是100
            //bg.addColorStop(0,'red'); //颜色设置为transparent
            //bg.addColorStop(0.5, 'orange');
            //bg.addColorStop(1, 'green'); //颜色设置为transparent 透明色
            //ctx.fillStyle = bg;
            //ctx.fillRect(0, 0, 400, 100);
        </script>
    </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            ctx.translate(200, 100);
            for(var i = 1;i < 60;i ++) {
                ctx.translate(30,30); //向右平移
                ctx.scale(0.95, 0.95); //缩放圆,变小 
                //ctx.transform(0.95, 0, 0, 0.95, 30, 30); 可以替换上面两行代码
                ctx.rotate(Math.PI/12); //每次在原来的基础上旋转30°

                ctx.beginPath();
                ctx.fillStyle = 'red';
                ctx.globalAlpha = '0.4'; //透明度
                ctx.arc(0, 0, 50, 0, Math.PI*2, true);
                ctx.closePath(); //做一个闭合图形的时候最好都带上closePath
                ctx.fill();
            }
        </script>
    </body>
</html>
```

```
globalCompositeOperation组合图形
ctx.globalCompositeOperation = 'source-over';
```

```
clearRect(x,y,dx,dy); //擦除当前区域
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            ctx.fillRect(0, 0, w, h);
            myCanvas.onmousemove = function(e) {
                ctx.clearRect(e.clientX - 25, e.clientY - 25, 50, 50); 
                //绑定一个鼠标事件,e.client鼠标的x方向,-25是把中心点移动到橡皮中间位置;
            };
        </script>
    </body>
</html>
```

```
矩形落地demo
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            var y = 0;
            ctx.fillRect(100, y, 50, 50);
            var timer = setInterval(function() {
                ctx.clearRect(0, 0, w, h); //每次进来都要清空画布
                y += 10;
                if(y >= 350) {
                    clearInterval(timer);
                    ctx.fillRect(100,350, 50, 50); //直接生成
                }else {
                    ctx.fillRect(100, y, 50, 50);
                }
            }, 50);
        </script>
    </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            canvas{
                border: 1px solid #000;
            }
        </style>
    </head>
    <body>
        <canvas id="myCanvas" width="400" height="400"></canvas>
        <script>
            var myCanvas = document.getElementById("myCanvas");
            var ctx = myCanvas.getContext('2d');
            
            var w = myCanvas.width,
                h = myCanvas.height;
            ctx.fillStyle = 'red'; //画布填充色 红色
            ctx.fillRect(0, 0, 400, 400); //范围是整个画布
            //采用新旧像素合并的方式擦除重叠区域;
            ctx.globalCompositeOperation = 'destination-out'; 
            myCanvas.onmousemove = function(e) {
                ctx.beginPath();
                ctx.arc(e.clientX, e.clientY, 50, 0, Math.PI*2);
                ctx.closePath();
                ctx.fillStyle = 'green';
                ctx.fill();
            };
        </script>
    </body>
</html>
```

```
绘制图像:
    1.drawImage导入图片,并抠图;
    	drawImage(image,x,y); 在画布上定位图像,插入到canvas的起始坐标;
    	drawImage(image,x,y,width,height); 在画布上定位图像,并规定图像的宽度和高度;
    	drawImage(image,sx,sy,swidth,sheight,x,y,width,height); 裁剪起始点坐标(sx,sy),以及裁剪的宽swidth,裁剪的高sheight,剪切图像,并在画布上定位被剪切的部分;在图片的(sx,sy)点为起点,以宽swidth和高sheight为大小进行裁剪,并且把裁剪后的图片放在canvas中的以点(x,y),以及宽和高进行放置;
    2.getImageDate(x,y,dx,dy); //同源策略,需要开服务器,在服务器上进行操作;
    3.createImageDate(w,h); //创建新的空白ImageDate对象;
    4.putImageDate(imgDate,x,y); //将图像数据放回画布上; 
```

```
1.抽取canvas为图片,是dom元素上的方法;
2.canvas.toDateURL();将canvas的内容抽取成一张图片,base64编码格式;
	注:同源策略的限制,要开启服务器,在www目录下打开
3.将canvas的内容放去img元素里;
```

```
模糊问题:
    1.位图像素放大会失真,canvas为位图像素;
    2.canvas绘图时,会从两个物理像素的中间位置开始绘制并向两边扩散0.5个物理像素。由于不存在0.5个像素,两边都取了1个像素,视觉上就造成了模糊。解决方案:放大再缩小。
```

```
SVG
使用:
    在线编辑工具 Method Draw
    地址:http://editor.method.ac/
    只要粘贴path元素放到svg便签中
html:
	<svg xmlns="http://www.w3.org/2000/svg" version="1.1"></svg>
js:
    var char = "http://www.w3.org/2000/svg";
    var svg = document.createElementNS(char,'svg');
注意:
	SVG元素对象一般通过调用setAttribute();方法来设定属性值;
应用场景:
    1.图形(脑图);百度脑图
    2.图标,logo(矢量图);放大不失真
    3.动效;
发展简史及支持情况:
    1.在2003年,SVG1.1被确定为W3C标准;
    2.Firefox、IE9+、Chrome、Safari;
基础元素:
    1.直线(起始点和终点);
    	<line x1="100" y1="100" x2="200" y2="100"></line>
    2.矩形(rx水平方向设置圆角和ry垂直方向设置圆角);
    	<rect x="100" y="100" width="100" height="100" rx="20" ry="50"></rect>
    3.圆形(中心点cx,cy和半径r);
    	<circle cx="100" cy="100" r="50"></circle>
    4.椭圆(圆心rx,ry和水平方向垂直方向的长轴和短轴cx,cy。属性可以写像素px,和canvas不一样);
    	<ellipse rx="100" ry="50" cx="250" cy="250"></ellipse>
    5.多边形(写各个边的顶点坐标);
    	<polygon points="100 100,70 150,130 150"></polygon>
    6.折线(点,像canvas一样会把起始点和结束点自动连接一下,然后自动填充颜色);
    	<polyline points="0 100,100 35,200 150,300 75,400 150,500 20"></polyline>
    7.字体(字体设定的位置坐标x,y);
    	<text x="300" y="300">蝉壳</text>
基础样式:
    1.fill: transparent;透明
    2.stroke: red;
    3.stroke-width: 10px;
    4.stroke-opacity/fill-opacity: 0.5;
    5.stroke-linecap: butt/round/square;
    6.stroke-linejoin: bevel/round/miter; 两条线交点处的样式
```

```
重要元素:
<path>元素可以定义一个路径,属性说明如下: 
    d:定义路径指令;
    M = moveto 移动到;
    L = lineto 画线到;
    H = horizontal lineto 水平画线到;
    V = vertical lineto 垂直画线到;
    C = curveto 三次贝塞尔曲线画线到;
    S = smooth curveto 光滑三次贝塞尔曲线画线到;
    Q = quadratic Bezier curve 二次贝塞尔曲线画线到,有一个起点终点和控制点;
    T = smooth quadratic Bezier curve 光滑二次贝塞尔曲线画线到;
    A = elliptical Arc 椭圆弧;
        <path d="M 100 100 A 70 120 0 1 1 150 200">
        起始点(100,100);
        终点(150,200);
        A里面的70 120代表椭圆的长轴和短轴;
        0代表旋转,先旋转后相交;
        前一个1代表取两点相交之间较长的部分;
        后一个1代表取顺时针部分;
    Z = closepath 关闭路径,后面没有属性值;
注:以上所有命令均允许大小写,大写表示绝对定位,小写表示相对定位;
```

```
<style>
	svg{
        border: 1px solid #000;
	}
	line{
        stroke: red; //画线比较特别
	}
	circle{
        fill: green; //也可以和宽高一样直接写在dom元素上
	}
	path{
        fill: transparent;
        stroke: #000;
	}
</style>
<body>
	<svg width="500" height="500" xmlns="http://www.w3.org/2000/svg" version="1.1">
		<line x1="100" y1="100" x2="200" y2="100"></line>
		<path d="M 100 100 L 400 100"></path>
	</svg>
</body>
```

```
路径属性:
1.stroke-dasharray: 100px; 
    1个值对应画多少空多少 ---> 虚线;
    2个值对应画和空 ---> 虚线;
    循环我们所填的值(顺序是画一下,空一下);
2.stroke-dashoffset: 15px;
	调整线往里缩;
注:getTotalLength获取路径长度
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            svg{
                border: 1px solid #000;
                stroke: #000;
                stroke-width: 3px;
                stroke-dasharray: 300px;
                stroke-dashoffset: 15px;
            }
        </style>
    </head>
    <body>
        <svg width="500" height="500" xmlns="http://www.w3.org/2000/svg" version="1.1">
            <path id="move" d="M 100 100 L 400 100"></path>
        </svg>
        <script>
            //做动画计时器
            var stroke = 0;
            var timer = setInterval(function() {
                stroke += 10;
                if(stroke < 300) {
                    move.style.strokeDashoffset = stroke + "px";
                }else {
                    clearInterval(timer);
                    move.style.strokeDashoffset = "300px"; //防止bug
                }
            }, 100);
        </script>
    </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            svg{
                border: 1px solid #000;
                stroke: #000;
                stroke-width: 3px;
                stroke-dasharray: 300px;
                stroke-dashoffset: 15px;
            }
        </style>
    </head>
    <body>
        <svg width="500" height="500" xmlns="http://www.w3.org/2000/svg" version="1.1">
            <path id="move" d="M 100 100 A 70 120 90 1 1 150 200" stroke="orange" stroke-width="3" fill="none"></path>
        </svg>
        <script>
            //做动画计时器
            var total = move.getTotalLength(); // 获取圆弧的总长度
            move.style.strokeDasharray = total + "px";
            var stroke = 0;
            var timer = setInterval(function() {
                stroke += 10;
                if(stroke < total) {
                    move.style.strokeDashoffset = stroke + "px";
                }else {
                    clearInterval(timer);
                    move.style.strokeDashoffset = total + "px";
                }
            }, 100);
        </script>
    </body>
</html>
```

```
渐变(了解即可):
1.线性渐变:
    <defs>
        <linearGradient id="bg1" x1="0" y1="0" x2="0" y2="100%">
            <stop offset="0%" style="stop-color:rgba(255,255,0);"/>
            <stop offset="100%" style="stop-color:rgba(255,0,0);"/>
        </linearGradient>
    </defs>
    <rect x="0" y="0" width="500" height="500" style="fill:yrl(#bg1)"/>
2.径向渐变:
    <defs>
        <radialGradient id="bg2" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
            <stop offset="0%" style="stop-color:green;"/>
            <stop offset="100%" style="stop-color:red;"/>
        </radialGradient>
    </defs>
```

```
滤镜:
1.高斯滤镜:
	<defs>
		<filter id="Gaussian_Blur">
			<feGaussianBlur in="SourceGraphic" stdDeviation="20"/>
		</filter>
	</defs>
	<rect x="0" y="0" width="500" height="500" fill="yellow" 			style="filter:url(#Gaussian_Blur)"/>
2.其他滤镜:
	http://www.w3chool.com.cn/svg/svg_filters_intro.asp
```

```
Drag和Drop拖放操作
拖放API:
绑定在被拖放元素上:
    dragstart 开始被拖拽时触发
    drag 在拖拽过程中触发
    dragend 拖拽完成时触发
绑定在目标元素上:
    dragenter 被拖放元素进入目标元素上时触发
    dragover 被拖放元素在目标元素上时触发
    dragleave 被拖放元素离开目标元素上时触发
    drop 被拖放元素在目标元素上同时鼠标放开时触发 (注:需要阻止dragover的默认行为才会触发drop事件)
```

```
DataTransfer对象:
    1.getData(); 向DataTransfer对象中存放数据
    2.setDate(); 从DateTransfer对象中读取数据
```

```
demo:把元素拖拽到目标区域
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            .drag, .drag2{
                width: 100px;
                height: 100px;
                background: #ccc;
                border-radius: 20px;
                text-align: center;
                line-height: 100px;
            }
            .target{
                position: absolute;
                right: 0;
                top: 0;
                width: 300px;
                height: 300px;
                border: 1px dashed #000; 
            }
        </style>
    </head>
    <body>
    	//draggable="true"属性就是可以拖动文件的灵魂
        <div class="drag" draggable="true">drag</div> 
        <div class="drag2" draggable="true">drag2</div>
        <div class="target">目标元素</div>
        <script>
            var drag = document.getElementsByClassName('drag')[0];
                drag2 = document.getElementsByClassName('drag2')[0];
                target = document.getElementsByClassName('target')[0];
            drag.addEventListener('dragstart', function(e) { 
                var dt = e.dataTransfer; //dataTransfer对象
                dt.setData('id', this.className); //传值,'id'是索引,与下文相对应
                console.log('dragstart');
            });
            drag2.addEventListener('dragstart', function(e) {
                var dt = e.dataTransfer;
                dt.setData('id', this.className);
                console.log('dragstart');
            });
            // drag.addEventListener('drag', function() {
            //     console.log('drag');
            // });
            // drag.addEventListener('dragend', function() {
            //     console.log('dragend');
            // });
            // target.addEventListener('dragenter', function() {
            //     console.log('dragenter');
            // });
            target.addEventListener('dragover', function(e) { //绑定在目标元素上
                e.preventDefault(); //取消默认事件,默认事件下是触发dragleave,不触发drap
                // console.log('dragover');
            });
            // target.addEventListener('dragleave', function() { //很少使用
            //     console.log('dragleave');
            // });
            target.addEventListener('drop', function(e) { //drop,被拖放元素在目标元素上同时鼠标放开时触发,需在dragover里面取消默认事件才能生效
                var dt = e.dataTransfer;
                var text = dt.getData('id');
                this.appendChild(document.getElementsByClassName(text)[0]); //把要拖拽的元素的dom获取,添加子元素到html中
                console.log(text);
            });
        </script>
    </body>
</html>
```

```
demo:拖拽元素到删除区域并且删除元素,还可以进行元素排序功能
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            body, ul, li{
            	margin: 0;
                padding: 0;
            }
            li{
                width: 200px;
                height: 40px;
                text-align: center;
                line-height: 40px;
                color: #fff;
                background: #ccc;
                margin: 20px;
            }
            .remove{
                width: 300px;
                height: 300px;
                background: #000;
                color: #fff;
            }
        </style>
    </head>
    <body>
        <ul>
            <li class="item1" draggable="true">列表1</li>
            <li class="item2" draggable="true">列表2</li>
            <li class="item3" draggable="true">列表3</li>
            <li class="item4" draggable="true">列表4</li>
            <li class="item5" draggable="true">列表5</li>
        </ul>
        <div class="remove">删除列表</div>
        <script>
            var li = document.getElementsByTagName('li'),
                remove = document.getElementsByClassName('remove')[0],
                ul = document.getElementsByTagName('ul')[0],
                len = li.length;
            function bindLiEvent(e) {
                for(var i = 0;i < len;i ++) {
                    // (function(j) { //j是形参,相当于上面的e,绑定一个立即执行函数,为啥?如果没有立即执行函数的话,光光执行下面三行代码,结果出来都是5了,我们只是在函数体里面定义了一个函数,并没有去执行所以需要使用到立即执行函数
                        li[i].addEventListener('dragstart', function(e) {
                            var dt = e.dataTransfer;
                            var index = findIndex(this, li);
                            dt.setData('data', index);
                        })
                    // })(i) //这个i是for循环中的i
                    li[i].addEventListener('dragover', function(e) {
                        e.preventDefault();
                    });
                    li[i].addEventListener('drop', function(e) {
                        var dt = e.dataTransfer;
                        var index = dt.getData('data'); //读取一下
                        console.log(index);
                        ul.insertBefore(li[index], this);
                    });
                }
            };
            function bindRemoveEvent() {
                remove.addEventListener('drop', function(e) {
                    var dt = e.dataTransfer;
                    var index = dt.getData('data');
                    console.log(index);
                    li[index].remove(); //删除dom元素
                });
                remove.addEventListener('dragover', function(e) { 
                    e.preventDefault();
                });
            };
            bindLiEvent();
            bindRemoveEvent();
            function findIndex(dom, list) {
                for(var i = 0;i < len;i ++) {
                    if(list[i] == dom) {
                        return i;
                    }
                }
            };
            //两个注意点:1.如何使用立即执行函数把每次的索引值传进去;2.发现立即执行函数还是存在问题,我们要实现的功能是将li数组进行排序,这样对应的数组就会有下标,当我们使用立即执行函数的时候,第一次是没有问题的,可是位置发生变化之后,对应的数组下标序号并没有改变,即一开始便固定好了索引值,而我们需要的是每次移动的时候,索引值是新鲜的
        </script>
    </body>
</html>
```

```
FileReader文件操作
fileList and file
    1.fileList:表示用户选择的文件列表;
    2.file:表示file控件内的每一个被选择的文件对象;
    3.fileList是这些file对象的列表;
```

```
fileReader对象:负责把文件读入内存,并且读取文件中的数据;
1.读取并显示文件:
    readAsText(); 将文件中的数据读取成文本数据(用的较多)
    readAsDataURL(); 将文件中的数据读取为DataURL字符串,对象是图片的话,我们可以用这个(用的较多)
    readAsBinaryString(); 将文件中的数据读取为二进制字符串
    readAsArrayBuffer(); 将文件中的数据读取为一个ArrayBuffer对象
    abort(); 中断文件读取操作
2.检测读取事件:
    onabort: 数据读取中断时触发;
    onprogress: 数据读取中触发;
    onerror: 数据读取出错时触发;
    onload: 数据读取成功时触发;
    onloadstart: 数据开始读取时触发;
    onloadend: 数据读取完成时触发(不论成功还是失败);
```

```
Blob对象:
    1.blob对象的访问;
    2.blob对象的创建;
    3.截取blob对象;
		var blob = new Blob(['asdf']);
		var reader = new FileReader();
		reader.readAsText(blob.slice(0,2)); //裁剪,从第0位开始往后裁剪两位
		//reader.readAsText(blob);
        reader.onload = function() {
            console.log(reader.result);
        };
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <input type="file" id="file" multiple>
        <input type="button" id="btn" value="提交">
        <script>
            var btn = document.getElementById('btn');
                file = document.getElementById('file');
            btn.onclick = function() {
                var list = file.files; //files是一个数组,数组的名字叫做fileList
                // console.log(list);
                var len = list.length;
                for(var i = 0;i < len;i ++) {
                    if(list[i].type == 'image/png') {
                        //执行上传代码
                        alert(list[i].name + '上传成功');
                        var reader = new FileReader();
                        reader.readAsDataURL(list[i]);
                        reader.onload = function() {
                            console.log(reader.result);
                            var img = new Image();
                            img.src = reader.result;
                            document.body.appendChild(img);
                        };
                    }
                    if(list[i].type == 'text/plain') { //如果上传的文件是一个text的时候,当我们不仅想要知道文本的格式,大小等基本信息,还想知道文本的内容是什么,用readAsText读取成文本的格式
                        var reader = new FileReader(); //读取的话需要有一个FileReader对象 
                        // console.log(reader);
                        reader.readAsText(list[i].slice(0,2)); //将文件中的数据读取成文本数据,读取的是这个文件
                        reader.onload = function() { //onload是读取成功时候触发的
                            console.log(reader.result); //文件读取的结果
                            //上传
                        };
                    }
                }
            }
        </script>
    </body>
</html>
```

```
优化Web动画
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            .demo{
                position: absolute; /*我们在做动画的时候一般都是需要设置定位的*/
                left: 0;
                top: 100px;
                width: 100px;
                height: 100px;
                background: pink;
            }
        </style>
    </head>
    <body>
        <div class="demo"></div>
        <script>
        	//setInterval计时器是每隔多少秒执行一次
            //var oDemo = document.getElementsByClassName('demo')[0];
            // var timer = setInterval(move, 100); 
            // function move() {
            //     var l = oDemo.offsetLeft;
            //     // console.log(l);
            //     if(l < 500) {
            //         oDemo.style.left = l + 10 + 'px';
            //     }else {
            //         oDemo.style.left = '500px'; //注意:如果超出了,强制地给她挪回到500px
            //         clearInterval(timer);
            //     }
            // };
            
            //setTimeout计时器是多少秒后执行,只执行一次
            var oDemo = document.getElementsByClassName('demo')[0];
            var timer2;
            function move() {
                var l = oDemo.offsetLeft;
                if(l < 500) {
                    oDemo.style.left = l + 9 + 'px';
                    timer2 = setTimeout(move, 100);
                }else {
                    oDemo.style.left = '500px';
                }
            };
            move();
        </script>
    </body>
</html>
```

```
计时器做动画存在以下3个问题:
	1.当前窗口不在动画页面时,计时器仍在继续工作,比较浪费CPU,尤其是在移动端;
	2.回调函数执行耗时,像是在排队,就像计时器执行每次时间间隔为100ms,我们函数执行一次需要200ms,这就会导致计时器时间间隔到了,而函数还没开始执行,对应的应该执行的第一次,第二次就会排队在队列中,当回调函数在队列排队较多时,浏览器就会瘫痪;
	3.设置动画频率高,像是过度绘制,会出现掉频。浏览器屏幕刷新频率为1000/60=16.7ms;当计时器执行的频率比浏览器刷新的频率还要快的时候,并没啥子软用,用户看到的还是依照浏览器刷新的频率来看的;
```

```
requestAnimationFrame优势:
	1.当前窗口不在动画页面时便停止工作;
	2.浏览器刷新屏幕时自动执行,无需设置时间间隔;
	3.浏览器内部自带优化;
requestAnimationFrame使用:
	1.req=requestAnimationFrame(cb); 屏幕每次绘制时执行回调函数cb
	2.cancelAnimationFrame(req);
```

```
requestAnimationFrame使用小例子:
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            .demo{
                position: absolute;
                left: 0;
                top: 100px;
                width: 100px;
                height: 100px;
                background: pink;
            }
        </style>
    </head>
    <body>
        <div class="demo"></div>
        <script>
            var oDemo = document.getElementsByClassName('demo')[0];
            function move() {
                var l = oDemo.offsetLeft;
                if(l < 500) {
                    oDemo.style.left = l + 9 + 'px';
                    requestAnimationFrame(move); //不需要设置执行时间
                }else {
                    oDemo.style.left = '500px';
                }
            };
            move();
        </script>
    </body>
</html>
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
        <style>
            .demo{
                position: absolute;
                left: 0;
                top: 100px;
                width: 100px;
                height: 100px;
                background: pink;
            }
        </style>
    </head>
    <body>
        <div class="demo"></div>
        <button id="stop">stop</button>
        <script>
            var oDemo = document.getElementsByClassName('demo')[0];
            var oStop = document.getElementById('stop');
            var req;
            function move() {
                var l = oDemo.offsetLeft;
                if(l < 1000) {
                    oDemo.style.left = l + 9 + 'px';
                    req = requestAnimationFrame(move); //不能在这里var req=...是为什么？因为我们需要的是设置一个计时器。如果在这里设置的话,会产生计时器叠加的效果,越来越快
                }else {
                    oDemo.style.left = '1000px';
                }
            };
            oStop.onclick = function() {
                cancelAnimationFrame(req);
            };
            move();
        </script>
    </body>
</html>
```

```
!由于早期浏览器不支持requestAnimationFrame,下面是兼容性写法:
window.requestAnimationFrame = (function(callback) { //立即执行函数
    return window.requestAnimationFrame ||
    	window.WebKitRequestAnimationFrame ||
    	window.mozRequestAnimationFrame ||
    	window.oRequestAnimationFrame ||
    	window.msRequestAnimationFrame ||
    	function() { //如果都不兼容上面这些浏览器,那么就退而求其次使用下面的
            window.setTimeout(callback, 1000/60)
    	}
})();
window.cancelAnimationFrame = (function(timer) { //立即执行函数
    return window.cancelAnimationFrame ||
    	window.WebKitcancelAnimationFrame ||
    	window.mozcancelAnimationFrame ||
    	window.ocancelAnimationFrame ||
    	window.mscancelAnimationFrame ||
    	function() {
            window.clearTimeout(timer)
    	}
})();
```

```
demo没得空的小球:
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <script>
            window.requestAnimationFrame = (function(callback) { //立即执行函数
                return window.requestAnimationFrame ||
                    window.WebKitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
    	            function() { //如果都不兼容上面这些浏览器,那么就退而求其次使用下面
                        window.setTimeout(callback, 1000/60)
    	            }
            })();
            var canvas,ctx;
            init();
            request();
            function init() {
                canvas = document.createElement('canvas');
                canvas.width= 210;
                canvas.height = 210;
                ctx = canvas.getContext('2d');
                document.body.appendChild(canvas);
            };
            function request() {
                requestAnimationFrame(request);
                draw();
            }
            function draw() {
                var time = new Date().getTime() * 0.002;
                var x = Math.sin(time) * 96 + 105;
                var y = Math.cos(time * 0.9) * 96 + 105;
                ctx.fillStyle = 'pink';
                ctx.fillRect(0, 0, 210, 210);
                ctx.fillStyle = 'rgb(255, 0, 0)';
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI*2, true);
                ctx.closePath();
                ctx.fill();
            }
        </script>
    </body>
</html>
```

```
Geolocation地理位置信息
Geolocation API
	1.window.navigator.geolocation对象: 返回经纬坐标等元数据信息;
	2.获取当前地理信息: navigator.geolocation.getCurrentPosition(suc, err, obj);
        参数1:suc 成功回调,有参数option,属性如下:
            longitude:-118.243890999999 经度;
            latitude:34.0653347 纬度;
            accuracy: 经纬度的精度;
            altitude:null 海拔;
            altitudeAccuracy:null 海拔的精度;
            heading:null 设备前进方向;
            speed:null 设备前进速度;
            timestamp: 获取地理位置信息的时间;
		参数2:err 失败回调,有参数error对象,属性如下:
            code属性:
                1.用户拒绝了位置服务;
                2.获取不到位置信息;
                3.获取信息超时;
            message属性:错误信息字符串;
        参数3:obj 可选参数:
            enableHighAccuracy: 是否要求高精度的地理位置信息,对应设置一个true;
            timeout: 超时限制;
            maximumAge: 缓存有效时间,若为0则无条件重新获取新地理信息即多久更新一次新的地理位置
    3.监事位置信息:
        var id = navigator.geolocation.watchPosition(suc,err,obj);
        持续定期的自动获取用户的当前地理位置信息,并同计时器一样有个位置标识。
    4.停止获取位置信息:
        navigator.geolocation.clearWatch(id);
```

```
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>demo</title>
    </head>
    <body>
        <script>
            var obj = { //获取地理位置需要设置一个时间
                timeout: 1000 //只给1s时间去获取地理位置,如果超过1s就会超时报错
            }
            navigator.geolocation.getCurrentPosition(suc, err, obj);
            function suc(position) { //成功以后会返回一个position对象
                console.log(position.coords.latitude + "," + position.coords.longitude);
            };
            function err(positionError) {
                console.log(positionError);
            };
        </script>
    </body>
</html>
```

```
!Geolocation地理位置信息这节课最后面有一个调用百度地图API做一个获取地理位置信息的小地图,需要在IE浏览器上实现,以后做！
```

```
Worker多线程处理
worker是一个子线程,需要在服务器下才能实现;
使用场景:
	大型数据运算,计时器,异步请求,访问navigator部分属性,js核心对象
使用Worker:
    //主进程文件
        var worker = new Worker('worker.js');
        worker.postMessage(10); //通过调用方法把10传到子线程中
        worker.onmessage = function(e) { //onmessage使用子线程传进来的值
            console.log(e.data);
        };
	//worker文件
        onmessage = function(e) { //用onmessage接收值
            var num = e.data; //经过大量计算返回一个值
            postMessage(num * 100); //通过postMessage把值返回主线程文件里
        };
结束worker:
    1.close(); 在worker文件中使用,子线程不干了
    2.terminate(); 在worker对象上调用(worker.terminate),主线程辞退子线程
局限性:
    1.不能跨域加载(所以要放到服务器下实现);
    2.worker文件不能访问DOM;
```

```
html:
    var worker = new Worker('./worker.js'); //创建一个worker,把worker拿过来
                worker.postMessage(10); //给子线程传值
                worker.onmessage = function(e) { //响应子线程传进来的结果
                    cosole.log(e.data);
                }; 
js:
    onmessage = function(e) { //响应一下主线程里传进来的值10
        console.log(e.data); //10
        var val = e.data * 10000 * 10000000 *10909; //进行了一个大量运算
        postMessage(val); //传给主线程
    };
```

