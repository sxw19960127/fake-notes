# 1.基本指令

作用：在渲染的`DOM`上应用特殊的响应式行为。

| {{ }}         | mustache语法（也叫插值表达式）                               |
| ------------- | ------------------------------------------------------------ |
| **v-text**    | **用于渲染文本，功能类似 {{ }}，不推荐使用因为不够灵活。采用了表达式的形式，会覆盖掉文本里的内容** |
| **v-html**    | **以 html 的形式解析渲染代码结构。采用了表达式的形式**       |
| **v-pre**     | **不交给 vue 去解析渲染目标代码段，我们写的是什么，呈现出来就是什么。单纯的指令** |
| **v-once**    | **页面数据仅渲染一次，以后数据的更新并不会触发目标对象进行数据重新更新操作。单纯的指令** |
| **v-cloak**   | **用以解决页面加载时候的闪烁问题。单纯的指令**               |
| **v-bind**    | **属性绑定机制，语法糖 `:`。内部可写一些简单合法的`js`表达式** |
| **v-on**      | **用于监听事件的绑定机制，语法糖 `@`**                       |
| **v-if**      | **条件判断指令**                                             |
| **v-else-if** | **条件判断指令**                                             |
| **v-else**    | **条件判断指令**                                             |
| **v-show**    | **决定元素要不要显示出来**                                   |
| **v-for**     | **循环遍历**                                                 |
| **v-model**   | **双向数据绑定，只应用于表单元素**                           |

# 2.代码演示

**插值表达式：**

```html
// 基本用法
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">{{ message }}</div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw'
         }
      })
   </script>
</body>
</html>
```

```html
// 双段号里还可以写一些简单的表达式
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h3>{{ firstName + lastName }}</h3>
      <h3>{{ firstName }} {{ lastName }}</h3>
      <h3>{{ firstName + ' ' + lastName }}</h3>
   </div>

   <script>
      const app = new Vue({
         el: '#app',
         data: {
            firstName: 'shu',
            lastName: 'xiaowei'
         }
      })
   </script>
</body>
</html>
```

**会覆盖文本里面的内容**：`v-text`、`v-html`

**v-text：**

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h3 v-text="message">此处内容被完全覆盖掉了</h3>
   </div>

   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw'
         }
      })
   </script>
</body>
</html>
```

**v-html：**

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h3 v-html="url">此处内容被完全覆盖掉了</h3>
   </div>

   <script>
      const app = new Vue({
         el: '#app',
         data: {
            url: '<a href="https://www.baidu.com">百度一下</a>'
         }
      })
   </script>
</body>
</html>
```

**v-pre：**

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h3 v-pre>{{ message }}</h3>
   </div>

   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw"
         }
      })
   </script>
</body>
</html>
```

**v-once：**我们可以在浏览器控制台通过 `app.message = 3`来改变`data`数据，可以发现页面并不会更新。

**v-cloak：**

存在闪烁问题：`{{}}`、`v-html`

```html
// 原理:
// 在还没有进行 vue 解析之前,目标元素身上是存在 v-cloak 属性的,即对应的 display: none;样式生效。当 vue 解析到目标代码的时候,也就是 vue 目前已经携带了 data 数据了,就会默认自动移除目标元素上的 v-cloak 属性,从而实现防止页面闪烁。
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      [v-cloak] {
         display: none;
      }
   </style>
</head>
<body>
   <div id="app">
      <h3 v-cloak>{{ message }}</h3>
   </div>

   <script>
      setTimeout(function() {
        const app = new Vue({
            el: '#app',
            data: {
               message: "sxw"
            }
         }) 
      }, 2000)
   </script>
</body>
</html>
```

**v-bind：**

动态绑定`class`属性

**对象形式**

方式1：原型本质

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: red;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="{color: true, fontSize: true}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw"
         }
      }) 
   </script>
</body>
</html>
```

方式2：抽离布尔值，方便动态修改

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: red;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="{color: isColor,fontSize: isLarger}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            isColor: true,
            isLarger: true
         }
      }) 
   </script>
</body>
</html>
```

方式3：简化`class`类名

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: red;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="getClass()">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            isColor: true,
            isLarger: true
         },
         methods: {
            getClass() {
               return {color: this.isColor,fontSize: this.isLarger}
            }
         }
      }) 
   </script>
</body>
</html>
```

---

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: red;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="getClass()">{{ message }}</span>
      <button v-on:click="changeColor()">pick me</button>
   </div>

   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            isColor: true,
            isLarger: true
         },
         methods: {
            changeColor() {
               this.isColor = !this.isColor
            },
            getClass() {
               return {color: this.isColor,fontSize: this.isLarger}
            }
         }
      }) 
   </script>
</body>
</html>
```

**数组形式**：数组语法动态绑定`class`属性。

方式1：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: red;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="['color','fontSize']">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw"
         }
      }) 
   </script>
</body>
</html>
```

方式2：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: green;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="[color, fontSize]">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            // 属性值就是样式中的属性名,注意要依次对上
            color: 'color',
            fontSize: 'fontSize'
         }
      }) 
   </script>
</body>
</html>
```

方式3：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .color{
         color: red;
      }
      .fontSize{
         font-size: larger;
      }
   </style>
</head>
<body>
   <div id="app">
      <span v-bind:class="getClass()">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: "sxw",
            color: 'color',
            fontSize: 'fontSize'
         },
         methods: {
            getClass() {
               return [this.color, this.fontSize]
            }
         }
      }) 
   </script>
</body>
</html>
```

`v-bind`动态绑定`style`样式属性：

**对象形式**：

方式1：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-bind:style="{color: 'red',fontSize: '100px'}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw'
         }
      })
   </script>
</body>
</html>
```

方式2：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-bind:style="{color: finalColor,fontSize: finalFontSize}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            finalColor: 'red',
            finalFontSize: '120px'
         }
      })
   </script>
</body>
</html>
```

方式3：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-bind:style="{color: finalColor,fontSize: finalFontSize + 'px'}">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            finalColor: 'red',
            finalFontSize: 10
         }
      })
   </script>
</body>
</html>
```

方式4：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-bind:style="getStyle()">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            finalColor: 'red',
            finalFontSize: 10
         },
         methods: {
            getStyle() {
               return {color: this.finalColor,fontSize: this.finalFontSize + 'px'}
            }
         }
      })
   </script>
</body>
</html>
```

**数组形式**：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-bind:style="[baseStyle1,baseStyle2]">{{ message }}</span>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            message: 'sxw',
            baseStyle1: {color: 'red'},
            baseStyle2: {fontSize: '100px'}
         }
      })
   </script>
</body>
</html>
```

**v-on**：

参数问题

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 情况1: 当事件调用的方法没有参数时,可以默认省略小括号(),以下两种方式是一样的 -->
      <button @click="btnClick">按钮A</button>
      <button @click="btnClick()">按钮B</button>

      <!-- 注意: 当事件方法本身具有一个参数时,我们不给其传递参数并且省略了小括号,那么Vue默认会将浏览器原生事件 event 当作参数传递到方法中 -->
      <button @click="btn2Click">按钮C</button>

      <!-- 正常传递参数的形式 -->
      <button @click="btn2Click('111')">按钮D</button>

      <!-- 函数需要参数,但没有进行传递,那么函数的形参为 undefined 输出 -->
      <button @click="btn2Click()">按钮E</button>

      <!-- 在方法定义的时候,我们需要 event 对象的同时又需要进行其他参数的传递,可通过 $event 实现 -->
      <button @click="btn3Click('111', $event)">按钮F</button>
      <!-- 下面的第一个参数是变量 sxw,那么他会自动去 data 中找变量 sxw -->
      <button @click="btn3Click(sxw, $event)">按钮G</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            sxw: 'The Chosen 1'
         },
         methods: {
            btnClick() {
               console.log('111')
            },
            btn2Click(event) {
               console.log(event)
            },
            btn3Click(a, event) {
               console.log(a,'---',event)
            }
         }
      })
   </script>
</body>
</html>
```

修饰符

`.stop` 阻止所有往外的冒泡，相当于原生的`event.stopPropagation()`

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <div @click="divClick">
         aaaaaa
         <!-- 当我们不添加 .stop 的时候,点击按钮事件会冒泡出去 -->
         <button @click.stop="btnClick">按钮</button>
      </div>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            divClick() {
               console.log('divClick')
            },
            btnClick() {
               console.log('btnClick')
            }
         }
      })
   </script>
</body>
</html>
```

`.prevent ` 阻止默认行为事件，相当于原生的`event.preventDefault()`

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <form action="baidu">
         <!-- 当我们不添加 .prevent 的时候,点击按钮会自动进行跳转提交,如果我们想要在定义的 submitClick 方法中自己书写业务逻辑进行提交,那么这显然是不符合的 -->
         <input type="submit" value="提交" @click.prevent="submitClick">
      </form>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            submitClick() {
               console.log('...')
            }
         }
      })
   </script>
</body>
</html>
```

`.enter` 监听键盘事件，还有`.tab`、`.delete`、`.esc`、`.space`、`.up`、`.down`、`.left`、`.right` 

[js键盘事件对应的keyCode码](http://www.cnblogs.com/wuhua1/p/6686237.html)

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 监听 enter 按键,在键盘抬起的时候触发事件 -->
      <input type="text" @keyup.enter="keyUp" />
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            keyUp() {
               console.log('...')
            }
         }
      })
   </script>
</body>
</html>
```

`.native` 监听组件根元素的原生事件

`.once` 只触发一次回调

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 只在第一次点击时有用,后面点击就没用了 -->
      <button @click.once="btnClick">按钮</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         methods: {
            btnClick() {
               console.log('....')
            }
         }
      })
   </script>
</body>
</html>
```

`.self` 只当事件在该元素本身触发时触发回调，不让子元素的事件触发自己绑定的事件，且不会阻止冒泡继续。

`.capture` 添加事件侦听器时，使用事件捕获模式。



**v-if、v-else-if、v-else**

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 通过控制 v-if 中的 flag 来进行界面显示和隐藏  -->
      <h1 v-if="flag">{{ msg }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 通过控制 v-if 中的 flag 来进行界面显示和隐藏  -->
      <h1 v-if="flag">{{ msg }}</h1>
      <h2 v-else>当 flag 为 false 的时候显示</h2>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h1 v-if="score >= 90">优秀</h1>
      <h1 v-else-if="score >= 70">良好</h1>
      <h1 v-else-if="score >= 60">及格</h1>
      <h1 v-else>不及格</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            score: 99
         }
      })
   </script>
</body>
</html>
```

使用计算属性优化上述需求：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h1>{{ result }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            score: 99
         },
         computed: {
            result() {
               let showMessage = ''
               if(this.score >= 90) {
                  showMessage = '优秀'
               }else if(this.score >= 70) {
                  showMessage = '良好'
               }else if(this.score >= 60) {
                  showMessage = '及格'
               }else {
                  showMessage = '不及格'
               }
               return showMessage
            }
         }
      })
   </script>
</body>
</html>
```

小案例：实现用户登录切换

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-if="isUser">
         <!-- for的作用: 当点击了用户账号文字时,对应的input框就会获得焦点 -->
         <label for="userName">用户账号</label>
         <input id="userName" type="text" placeholder="用户账号">
      </span>

      <span v-else>
         <label for="email">用户邮箱</label>
         <input id="email" type="text" placeholder="用户邮箱" />
      </span>

      <button @click="isUser = !isUser">切换</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            isUser: true // 改变 isUser 变量的值来控制上述哪个 span 标签显示隐藏
         }
      })
   </script>
</body>
</html>
```

==注意==：上述代码存在一个`bug`，设计到`Vue`底层原理，即（当用户往`input`中输入内容后，发现自己需要切换一种模式去输入内容。然而在切换之后，原先输入框中的内容依旧存在，而不是我们想要的，当用户切换一种模式时，输入框中的内容会被自动清除掉。）这是为什么呢？我们回到代码，发现用户账号和用户邮箱下明明是两个独立的`input`框，当用户点击切换时，理应是自动置空的呀，可为什么实现起来不是这样的？

![虚拟dom](C:\Users\lenovo\Desktop\2019年11月19日始\notes\Vue\img\虚拟dom.png)

==辨析==：因为`Vue`在进行`DOM`渲染的时候，处于性能考略，会尽可能地复用已经存在了的元素，而不是重新渲染新元素。在上面这个案例中，`Vue`内部会发现原来的`input`元素已经不在使用了，通过对比（`diff`算法）发现即将要渲染的`DOM`元素于之前的`input`相似，然后`Vue`就直接将其再次渲染并作为`else`中的`input`来使用，这么懒！

`Vue`真正在渲染元素的时候，并不会直接将我们的元素渲染到页面上去。而是先将元素渲染到虚拟 `dom`中去，也就是放到内存中去。再将虚拟`dom`中的内容渲染到页面。

上面的例子中，两种可能并不会同时渲染到页面中去。所以虚拟`dom`进行渲染的时候，会先看看自己内存中有没有保存了一份，而不会在虚拟`dom`中重新创建出一份来。将原先的那些东西往我们的界面上进行渲染，然后你会发现我们现在在用的依旧是我们之前在页面中使用的`label`、`input`。但是在渲染页面的时候，虚拟`dom`还会进行一个对比，将目标`DOM`中改变了的属性重新渲染，而对于渲染的多余的属性（也就是我们在一种模式下`input`中输入的值）并不会进行删除操作。所以当用户输入一个`333`的时候， `<input value="333" />`中的`value`属性并不会被删除，而是直接被渲染出来了。

==解决方案==：在不同的`input`后面添加一个属性`key`作为唯一标识。`key`值的不同则表示我这个`input`是独一无二的。当拥有属性`key`值不同的时候，虚拟`dom`在渲染的时候，就不会将其复用了。

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <span v-if="isUser">
         <!-- for的作用: 当点击了用户账号文字时,对应的input框就会获得焦点 -->
         <label for="userName">用户账号</label>
         <input id="userName" type="text" placeholder="用户账号" :key="1" />
      </span>

      <span v-else>
         <label for="email">用户邮箱</label>
         <input id="email" type="text" placeholder="用户邮箱" :key="2" />
      </span>

      <button @click="isUser = !isUser">切换</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            isUser: true // 改变 isUser 变量的值来控制上述哪个 span 标签显示隐藏
         }
      })
   </script>
</body>
</html>
```

**v-show**：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <h1 v-show="flag">{{ msg }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
</html>
```

**辨析 v-show 和 v-if**

使用建议：当需要频繁实现显示和隐藏的时候，使用`v-show`。当只有一次切换的时候，使用`v-if`。

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 两者都是隐藏元素,但是 v-show 是给目标元素的行内样式添加了一个 display: none;属性,实现隐藏;而 v-if 是直接将元素给删除了  -->
      <h1 v-show="flag">{{ msg }}</h1>
      <h1 v-if="flag">{{ msg }}</h1>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            msg: 'sxw',
            flag: true
         }
      })
   </script>
</body>
</html>
```

**v-for**：

遍历数组

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="item in names">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            names: ['a','b','c']
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="(item,index) in names">{{ index }} - {{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            names: ['a','b','c']
         }
      })
   </script>
</body>
</html>
```

遍历对象

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <!-- 遍历对象时,如果只获取到了一个值,那么获取到的是 value -->
         <li v-for="item in obj">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            obj: {
               name: 'sxw',
               age: 18
            }
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="(value,key) in obj">{{ key }} - {{ value }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            obj: {
               name: 'sxw',
               age: 18
            }
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="(value,key,index) in obj">{{ index }} - {{ key }} - {{ value }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            obj: {
               name: 'sxw',
               age: 18
            }
         }
      })
   </script>
</body>
</html>
```

遍历数字：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="i in 3">{{ i }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app'
      })
   </script>
</body>
</html>
```

遍历字符串：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="num in 'shuxiaowei'">{{ num }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app'
      })
   </script>
</body>
</html>
```

==注意==：官方推荐我们在使用`v-for`的时候，给对应的元素或者组件添加一个`:key`属性，实现更好的复用。即：在组件中使用`v-for`进行遍历的时候，`key`值是必须的。提供了唯一的`key`值以便跟踪每个节点的身份，重用和重新排序现有元素，并且`key`值只接受`number`或`string`类型。

为什么说添加一个`key`要更好？

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <!-- 需求: 现在我们要在渲染出来的 A 和 B 之间插入一个新元素 D,那么 key 就起到作用了 -->
         <li v-for="item in arr" :key="item">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            arr: ['A','B','C']
         }
      })
   </script>
</body>
</html>
```

![v-for循环时的key值](C:\Users\lenovo\Desktop\2019年11月19日始\notes\Vue\img\v-for循环时的key值.png)

不用去遗憾和后悔，过好当前的每一秒比什么都强。已经过去的不能去改变什么，珍惜当下的每一秒才有意义。

数组哪些方法是响应式的，哪些不是响应式行为的呢？

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="(item,index) in arr" :key="item + index">{{ item }}</li>
      </ul>
      <button @click="btnClick">按钮</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            arr: ['A','B','C']
         },
         methods: {
            btnClick() {
               // 响应式的数组方法:
               // 1.push() 里面的参数可以有多个,在数组最后追加元素
               // this.arr.push('D','E')

               // 2.pop() 将数组最后一个元素删除掉
               // this.arr.pop()

               // 3.shift() 将数组第一个元素删除掉
               // this.arr.shift()

               // 4.unshift() 往数组头部添加元素
               // this.arr.unshift('D')

               // 5.splice() 可以删除/插入/替换元素
               // 删除元素: 有两个参数,第一个参数是起始位置,第二个参数是要删除的元素个数,若没有传递,则表示删除起始位置后面的所有的元素
               // this.arr.splice(1) //删除 A 后面的所有元素
               // this.arr.splice(1,1) //删除 A 后面的1个元素也就是删除 B
               // 替换元素: 也是有两个参数,第一个参数同上,第二个参数表示我们要替换几个元素,然后后面跟着的是用于替换的具体元素
               // this.arr.splice(1,1,'D') //从第一位后面替换1个元素,并且用 D 进行替换
               // this.arr.splice(1,1,'D','E','F')
               // 注意: 当第二个参数为 0 的时候，即表示插入元素
               // this.arr.splice(1,0,'D','E')

               // 6.sort() 排序
               // this.arr.sort() // 里面可以传递一个函数

               // 7.reverse() 反转
               // this.arr.reverse()
               
               // 8.Vue内部自带的 set 方法
               // set(要修改的对象,索引值,要修改成)
               Vue.set(this.letter, 0, '111') //将 A 修改为 '111'
            }
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
</head>
<body>
   <div id="app">
      <ul>
         <li v-for="(item,index) in arr" :key="item + index">{{ item }}</li>
      </ul>
      <button @click="btnClick">按钮</button>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            arr: ['A','B','C']
         },
         methods: {
            btnClick() {
               // 非响应式的数组方法:
               // 数据确实发生了改变,但是界面并没有重新渲染,因为 Vue 内部没有监听这种方法去重新渲染我们的数据。不过我们可以使用 splice 去代替这种方法实现效果。
               console.log(this.arr[0]) // A
               this.arr[0] = '111'
            }
         }
      })
   </script>
</body>
</html>
```

**拓展**：可遍数组

```js
// ...num 会将我们传入的所有数据都存放到一个数组中保存起来
function sum(...num) {
    console.log(num)
}
sum(1,2,3,4,5,6,7)
```

**练习**：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      .active{
         color: red;
      }
   </style>
</head>
<body>
   <div id="app">
      <ul>
         <!-- 点击哪个 li 哪个 li 变红 -->
         <li 
            v-for="(item,index) in movies" 
            :key="item + index"
            :class="{active: aimIndex === index}"
            @click="liClick(index)">{{ item }}</li>
      </ul>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            movies: ['绿皮书','了不起的盖茨比','楚门的世界'],
            aimIndex: 0 // 第一个 li 变红
         },
         methods: {
            liClick(index) {
               this.aimIndex = index
            }
         }
      })
   </script>
</body>
</html>
```

项目练习：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./vue.js"></script>
   <style>
      tabel{
         border: 1px solid #e9e9e9;
         border-collapse: collapse;
         border-spacing: 0;
      }
      th, td{
         padding: 8px 16px;
         border: 1px solid #e9e9e9;
         text-align: left;
      }
      th{
         background-color: #f7f7f7;
         color: #5c6b77;
         font-weight: 600;
      }
   </style>
</head>
<body>
   <div id="app">
      <div v-if="books.length">
         <table>
            <thead>
               <tr>
                  <th></th>
                  <th>书籍名称</th>
                  <th>出版日期</th>
                  <th>价格</th>
                  <th>购买数量</th>
                  <th>操作</th>
               </tr>
            </thead>
            <tbody>
               <tr v-for="(item,index) in books">
                  <td>{{ item.id }}</td>
                  <td>{{ item.name }}</td>
                  <td>{{ item.date }}</td>
                  <!-- <td>{{ getFinalPrice(item.price) }}</td> -->
                  <td>{{ item.price | showPrice }}</td>
                  <td>
                     <button @click="decrement(index)" :disabled="item.count <= 1">-</button>
                     {{ item.count }}
                     <button @click="increment(index)">+</button>
                  </td>
                  <td><button @click="removeHandle(index)">移除</button></td>
               </tr>
            </tbody>
         </table>
         <h2>总价格：{{ totalPrice | showPrice }}</h2>
      </div>
      <h2 v-else>购物车为空</h2>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            books: [
               {
                  id: 1,
                  name: '《算法1》',
                  date: '2019-1',
                  price: 12.00,
                  count: 1
               },
               {
                  id: 2,
                  name: '《算法2》',
                  date: '2019-2',
                  price: 22.00,
                  count: 1
               },
               {
                  id: 3,
                  name: '《算法3》',
                  date: '2019-3',
                  price: 32.00,
                  count: 1
               },
               {
                  id: 4,
                  name: '《算法4》',
                  date: '2019-4',
                  price: 42.00,
                  count: 1
               }
            ]
         },
         methods: {
            // 方式1.处理我们要呈现出来的价格
            getFinalPrice(price) {
               // .toFixed(2) 保留两位小数
               return '￥' + price.toFixed(2)
            },
            increment(index) {
               this.books[index].count ++
            },
            decrement(index) {
               this.books[index].count --
            },
            removeHandle(index) {
               this.books.splice(index, 1)
            }
         },
         computed: {
            totalPrice() {
               // 1.普通的 for 循环
               // let totalPrice = 0
               // for(let i = 0;i < this.books.length;i ++) {
               //    totalPrice += this.books[i].price * this.books[i].count
               // }
               // return totalPrice;

               // 2.for(let i in this.books) 拿到的是每一项的索引值
               // let totalPrice = 0
               // for(let i in this.books) {
               //    // console.log(i) 拿到的i是索引值
               //    totalPrice += this.books[i].price * this.books[i].count
               // }
               // return totalPrice;

               // 3.直接拿到数组中的每一项
               // let totalPrice = 0
               // for(let item of this.books) {
               //    totalPrice += item.price * item.count
               // }
               // return totalPrice

               // 4.高阶函数 reduce
               return this.books.reduce(function(preValue, book) {
                  return preValue + book.price * book.count
               }, 0)
            }
         },
         // 方式2.使用过滤器处理价格
         filters: {
            showPrice(price) {
               return '￥' + price.toFixed(2)
            }
         }
      })
   </script>
</body>
</html>
```









