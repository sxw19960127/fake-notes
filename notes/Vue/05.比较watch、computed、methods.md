# `watch`、`computed`、`methods`三者之间的比较

**computed**：会分析数据的变化是否于自己所定义的函数所涉及的数据相关，而后相应地进行更新。结果会被缓存起来，除非依赖地响应式属性变化，才会重新计算结果。主要当作属性进行使用，只能书写同步操作，即数据发生变化之后自动监听响应式反应。

**watch**：键是需要观察的表达式，值是对应的回调函数。主要用来监听某些特定数据的变化，从而进行具体的业务逻辑操作。可看作是`computed`和`methods`的结合体，不需要返回值，直接书写逻辑操作，支持异步。

**methods**：表示一个具体的操作，主要用来书写业务逻辑。使用原生函数执行的方式，只要页面上的数据发生了变化，对应函数都会被执行，用以确保此时渲染的数据始终是最新的，耗费性能。

```html
// 使用这种方式不好之处在于: 我们一般是在 {{}} 双段号里面书写属性的名字的,而这里则是写了一个方法,让人看起来不舒服
<h1>{{ getFullName() }}</h1>
methods: {
	getFullName() {
		return this.firstName + this.lastName;
	}
}
```

使用计算属性优化上述代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./Vue.js"></script>
</head>
<body>
   <div id="app">
      <!-- 使用计算属性的时候,不需要加 ()  -->
      <h2>{{ fullName }}</h2>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            firstName: 'shu',
            lastName: 'xiaowei'
         },
         computed: {
            // 是计算属性,所以我们在取名字的时候一般按照属性的形式进行取名 
            fullName() {
               return this.firstName + this.lastName
            }
         }
      })
   </script>
</body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta http-equiv="X-UA-Compatible" content="ie=edge">
   <title>Document</title>
   <script src="./Vue.js"></script>
</head>
<body>
   <div id="app">
      <h2>总价格：{{ totalPrice }}</h2>
   </div>
   <script>
      const app = new Vue({
         el: '#app',
         data: {
            books: [
               {id: 1,name: '红宝书1',price: 80},
               {id: 2,name: '红宝书2',price: 70},
               {id: 3,name: '红宝书3',price: 60},
            ]
         },
         // 计算属性在多次调用的时候只会调用一次,而methods是你调用几次,他就会执行几次,没有缓存且性能低
         computed: {
            // 既然是属性了,我们就不要起动词的名字了
            totalPrice() {
               let result = 0;
               for(let i = 0;i < this.books.length;i ++) {
                  result += this.books[i].price
               }
               return result;
                
               // for(let i in this.books) {
               //   this.books[i]
               // }
               
               // for(let book of this.books) {
               //   ...
               // }
            }
         }
      })
   </script>
</body>
</html>
```

