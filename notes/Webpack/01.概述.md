# 1.历史进程

在没有`Webpack`之前，也就是没有模块化之前，存在三点明显的缺陷：

- 开发代码可读性差。
- 文件函数之间存在关联性（耦合性）问题。
- 不利于团队的协作开发。

---

**解决上述问题，经历了很长的历史进程**：

- `IIFE`，立即执行函数的出现

![污染全局变量](C:\Users\lenovo\Desktop\2019年11月19日始\notes\Webpack\img\污染全局变量.png)

问题1：上述引入外部`js`脚本，可能存在作用域以及污染全局变量的问题。

解决方法：

```js
(function () {
    function con(value) {
        console.log(value);
    }
    function add(a,b) {
        con(a + b);
    }
    
    // 通过window方法暴露给全局我们想要暴露出去的部分
    window.add = add
})()
```

问题2：存在引入依赖问题。

解决方法：`gulp`、`grunt`等工具的出现。

问题3：上述的解决方法就是在文件首部添加一个说明，用来描述当前文件是否需要加载别的依赖文件，以及依赖的先后顺序。但当我们修改了文件内容时，可能会打破这个依赖规则。并且上述这个方法存在`Dead Code`死代码现象，也就是说当我们仅仅需要使用目标库中的一个插件的时候，她会加载整个目标库，造成资源浪费。`eg`：`underscore.js`、`lodash`等。

解决方法：`commonJS`模块化导出的出现。

```js
// 文件导出
function add(a,b) {
    console.log(a + b);
}
module.export = add;
```

```js
// 文件引入
let add = require('./add');
```

但是使用上述方法，浏览器是无法识别`require`、`export`等语法的。

解决方法：`browerify`打包工具的出现。但是其打包固化，并且无法按需加载，造成资源浪费等问题。她只是将所有的文件打包成一个`js`文件，存在代码冗余。

解决方法：出现了两个异步加载的规范。

**AMD**：代表`Require.js`

**CMD**：代表`Sea.js` 国人写的

最后，`Webpack`的出现！

# 2.`Webpack`出现

**概述**：前端打包工具，支持任意模块化的语法，采用按需加载、异步加载的方式，将很多的`js`、`css`文件整合成一个`js`文件。项目上线的时候只需要将那一个导出的文件丢上去即可。是目前为止，解决模块化比较好的方案！



